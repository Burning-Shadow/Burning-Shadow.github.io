<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/siir.jpg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/siir.jpg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/siir.jpg?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="​        作为最常用的静态模块打包工具之一 webpack 困扰也哺育着成千上万的前端开发，我们都知道 input output，modules plugins loader，可是站在更高一层的角度看这些都有什么区别？什么作用？实现原理是 js 中的哪一种数据结构？恐怕很少有人去考量。所以今天我们试着一探究竟。 ​        本文转载自SegmentFault的whjin，原文地址：h">
<meta name="keywords" content="webpack">
<meta property="og:type" content="article">
<meta property="og:title" content="Webpack原理（转载）">
<meta property="og:url" content="http://yoursite.com/2019/08/18/Webpack原理初探/index.html">
<meta property="og:site_name" content="Siir">
<meta property="og:description" content="​        作为最常用的静态模块打包工具之一 webpack 困扰也哺育着成千上万的前端开发，我们都知道 input output，modules plugins loader，可是站在更高一层的角度看这些都有什么区别？什么作用？实现原理是 js 中的哪一种数据结构？恐怕很少有人去考量。所以今天我们试着一探究竟。 ​        本文转载自SegmentFault的whjin，原文地址：h">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://ae01.alicdn.com/kf/Ha80f13a83fa7456089be842c12a8af55u.png">
<meta property="og:updated_time" content="2019-11-16T12:46:00.657Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Webpack原理（转载）">
<meta name="twitter:description" content="​        作为最常用的静态模块打包工具之一 webpack 困扰也哺育着成千上万的前端开发，我们都知道 input output，modules plugins loader，可是站在更高一层的角度看这些都有什么区别？什么作用？实现原理是 js 中的哪一种数据结构？恐怕很少有人去考量。所以今天我们试着一探究竟。 ​        本文转载自SegmentFault的whjin，原文地址：h">
<meta name="twitter:image" content="https://ae01.alicdn.com/kf/Ha80f13a83fa7456089be842c12a8af55u.png">






  <link rel="canonical" href="http://yoursite.com/2019/08/18/Webpack原理初探/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Webpack原理（转载） | Siir</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Siir</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Schlagwörter</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Kategorien</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/18/Webpack原理初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Webpack原理（转载）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-08-18 12:49:00" itemprop="dateCreated datePublished" datetime="2019-08-18T12:49:00+08:00">2019-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-11-16 20:46:00" itemprop="dateModified" datetime="2019-11-16T20:46:00+08:00">2019-11-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/打包工具/" itemprop="url" rel="index"><span itemprop="name">打包工具</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>​        作为最常用的静态模块打包工具之一 <code>webpack</code> 困扰也哺育着成千上万的前端开发，我们都知道 <code>input</code> <code>output</code>，<code>modules</code> <code>plugins</code> <code>loader</code>，可是站在更高一层的角度看这些都有什么区别？什么作用？实现原理是 js 中的哪一种数据结构？恐怕很少有人去考量。所以今天我们试着一探究竟。</p>
<p>​        本文转载自<code>SegmentFault</code>的<a href="https://segmentfault.com/u/whjin" target="_blank" rel="noopener"><strong>whjin</strong></a>，原文地址：<a href="https://segmentfault.com/a/1190000015088834#articleHeader17。" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015088834#articleHeader17。</a></p>
<a id="more"></a>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>初学 <code>webpack</code> 的小伙伴想必和我有一样的问题：<code>webpack</code> 是什么？</p>
<p>​        简而言之，<code>webpack</code> 算是一个集成打包、压缩功能的前端编译工具。而真正将其 引入历史舞台的原因，引用表严肃表哥的一句话：<code>浏览器实现之初没有做到模块化，之后都是在补作业</code> 。所以 <code>webpack</code> 的作用我们就可以理解为：使前端页面得以通过模块化加载方式进行载入。</p>
<p>​    当然，打包压缩什么的算是后话，原理暂时这么记。</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul>
<li><code>Entry</code>： 入口文件</li>
<li><code>Module</code>：最终打包完成的<code>bundle</code>放至何处</li>
<li><code>Chunk</code>：代码块。一个<code>Chunk</code>由多个模块组合而成，用于代码合并与分割。</li>
<li><code>Loader</code>：用<code>loader</code>处理非 JS 文件，将其转化为<code>webpack</code>所能处理的有效模块（JS、JSX）</li>
<li><code>Plugin</code>：插件。用于打包优化、压缩、重新定义环境中的变量等等。。。</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><ol>
<li>初始化参数：从配置文件和<code>Shell</code>语句中读取与合并参数，得出最终的参数</li>
<li>开始编译：用上一步得到的参数初始化<code>Complier</code>对象，加载所有的配置的插件，执行对象的<code>run</code>方法开始执行编译</li>
<li>确定入口：找<code>entry</code></li>
<li>编译模块：从入口文件出发，调用所有配置的<code>loader</code>对模块进行编译，再找出该模块的依赖模块，直至所有入口文件的依赖文件都经过本步骤的处理</li>
<li>完成模块编译：经过<code>Loader</code>翻译完所有模块后得到的是他们被翻译后的内容及它们之间的依赖关系</li>
<li>输出资源：根据入口和模块之间的依赖关系组成一个个包含多个模块的<code>Chunk</code>，再把美个<code>Chunk</code>转换成一个单独的文件加入到输出列表。这步是修改输出内容的最后机会</li>
<li>输出完成：确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol>
<li>初始化：启动构建，读取与合并配置参数，加载<code>Plugin</code>，实例化<code>Compiler</code>。</li>
<li>编译：从<code>Entry</code>发出，针对每个<code>Module</code>串行调用对应的<code>Loader</code>去翻译文件内容，再找到该<code>Module</code>依赖的<code>Module</code>，递归地进行编译处理。</li>
<li>输出：将编译后的<code>Module</code>组合成<code>Chunk</code>，把<code>Chunk</code>转换成文件，输出到文件系统。</li>
</ol>
<p>当然，如果你开启了监听模式，那么整个流程会变成这样</p>
<p><img src="https://ae01.alicdn.com/kf/Ha80f13a83fa7456089be842c12a8af55u.png" alt></p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><table>
<thead>
<tr>
<th style="text-align:left">事件名</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">初始化参数</td>
<td style="text-align:left">从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 <code>new Plugin()</code>。</td>
</tr>
<tr>
<td style="text-align:left">实例化 <code>Compiler</code></td>
<td style="text-align:left">用上一步得到的参数初始化 <code>Compiler</code> 实例，<code>Compiler</code> 负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 <code>Webpack</code> 配置，全局只有一个 <code>Compiler</code> 实例。</td>
</tr>
<tr>
<td style="text-align:left">加载插件</td>
<td style="text-align:left">依次调用插件的 <code>apply</code> 方法，让插件可以监听后续的所有事件节点。同时给插件传入 <code>compiler</code> 实例的引用，以方便插件通过 <code>compiler</code> 调用 Webpack 提供的 API。</td>
</tr>
<tr>
<td style="text-align:left"><code>environment</code></td>
<td style="text-align:left">开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。</td>
</tr>
<tr>
<td style="text-align:left"><code>entry-option</code></td>
<td style="text-align:left">读取配置的 <code>Entrys</code>，为每个 <code>Entry</code> 实例化一个对应的 <code>EntryPlugin</code>，为后面该 <code>Entry</code> 的递归解析工作做准备。</td>
</tr>
<tr>
<td style="text-align:left"><code>after-plugins</code></td>
<td style="text-align:left">调用完所有内置的和配置的插件的 <code>apply</code> 方法。</td>
</tr>
<tr>
<td style="text-align:left"><code>after-resolvers</code></td>
<td style="text-align:left">根据配置初始化完 <code>resolver</code>，<code>resolver</code> 负责在文件系统中寻找指定路径的文件。</td>
</tr>
</tbody>
</table>
<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><table>
<thead>
<tr>
<th style="text-align:left">事件名</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>run</code></td>
<td style="text-align:left">启动一次新的编译。</td>
</tr>
<tr>
<td style="text-align:left"><code>watch-run</code></td>
<td style="text-align:left">和 <code>run</code> 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译。</td>
</tr>
<tr>
<td style="text-align:left"><code>compile</code></td>
<td style="text-align:left">该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 <code>compiler</code> 对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>compilation</code></td>
<td style="text-align:left">当 <code>Webpack</code> 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。</td>
</tr>
<tr>
<td style="text-align:left"><code>make</code></td>
<td style="text-align:left">一个新的 <code>Compilation</code> 创建完毕，即将从 <code>Entry</code> 开始读取文件，根据文件类型和配置的 <code>Loader</code> 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。</td>
</tr>
<tr>
<td style="text-align:left"><code>after-compile</code></td>
<td style="text-align:left">一次 <code>Compilation</code> 执行完成。</td>
</tr>
<tr>
<td style="text-align:left"><code>invalid</code></td>
<td style="text-align:left">当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 Webpack 退出。</td>
</tr>
</tbody>
</table>
<p>​    在编译阶段中，最重要的要数 <code>compilation</code> 事件了，因为在 <code>compilation</code> 阶段调用了 Loader 完成了每个模块的转换操作，在 <code>compilation</code> 阶段又包括很多小的事件，它们分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">事件名</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>build-module</code></td>
<td style="text-align:left">使用对应的 Loader 去转换一个模块。</td>
</tr>
<tr>
<td style="text-align:left"><code>normal-module-loader</code></td>
<td style="text-align:left">在用 Loader 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 Webpack 后面对代码的分析。</td>
</tr>
<tr>
<td style="text-align:left"><code>program</code></td>
<td style="text-align:left">从配置的入口模块开始，分析其 AST，当遇到 require 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。</td>
</tr>
<tr>
<td style="text-align:left"><code>seal</code></td>
<td style="text-align:left">所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk。</td>
</tr>
</tbody>
</table>
<h4 id="输出阶段"><a href="#输出阶段" class="headerlink" title="输出阶段"></a>输出阶段</h4><table>
<thead>
<tr>
<th style="text-align:left">事件名</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>should-emit</code></td>
<td style="text-align:left">所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td>
</tr>
<tr>
<td style="text-align:left"><code>emit</code></td>
<td style="text-align:left">确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td>
</tr>
<tr>
<td style="text-align:left"><code>after-emit</code></td>
<td style="text-align:left">文件输出完毕。</td>
</tr>
<tr>
<td style="text-align:left"><code>done</code></td>
<td style="text-align:left">成功完成一次完成的编译和输出流程。</td>
</tr>
<tr>
<td style="text-align:left"><code>failed</code></td>
<td style="text-align:left">如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td>
</tr>
</tbody>
</table>
<p>​        在输出阶段已经得到了各个模块经过转换后的结果和其依赖关系，并且把相关模块组合在一起形成一个个 <code>Chunk</code>。 在输出阶段会根据<code>Chunk</code>的类型，使用对应的模版生成最终要要输出的文件内容。</p>
<h3 id="输出文件分析"><a href="#输出文件分析" class="headerlink" title="输出文件分析"></a>输出文件分析</h3><p>​        虽然在前面的章节中你学会了如何使用 Webpack ，也大致知道其工作原理，可是你想过 Webpack 输出的 <code>bundle.js</code> 是什么样子的吗？ 为什么原来一个个的模块文件被合并成了一个单独的文件？为什么 <code>bundle.js</code> 能直接运行在浏览器中？ 本节将解释清楚以上问题。</p>
<p>​        先来看看由 安装与使用 中最简单的项目构建出的 <code>bundle.js</code> 文件内容，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    <span class="comment">// webpackBootstrap 启动函数</span></span><br><span class="line">    <span class="comment">// modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 安装过的模块都存放在这里面</span></span><br><span class="line">        <span class="comment">// 作用是把已经加载过的模块缓存在内存中，提升性能</span></span><br><span class="line">        <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去数组中加载一个模块，moduleId 为要加载模块在数组中的 index</span></span><br><span class="line">        <span class="comment">// 作用和 Node.js 中 require 语句相似</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果需要加载的模块已经被加载过，就直接从内存缓存中返回</span></span><br><span class="line">            <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">                <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中</span></span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">                <span class="comment">// 模块在数组中的 index</span></span><br><span class="line">                i: moduleId,</span><br><span class="line">                <span class="comment">// 该模块是否已经加载完毕</span></span><br><span class="line">                l: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// 该模块的导出值</span></span><br><span class="line">                exports: &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 modules 中获取 index 为 moduleId 的模块对应的函数</span></span><br><span class="line">            <span class="comment">// 再调用这个函数，同时把函数需要的参数传入</span></span><br><span class="line">            modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">            <span class="comment">// 把这个模块标记为已加载</span></span><br><span class="line">            <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 返回这个模块的导出值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Webpack 配置中的 publicPath，用于加载被分割出去的异步代码</span></span><br><span class="line">        __webpack_require__.p = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 __webpack_require__ 去加载 index 为 0 的模块，并且返回该模块导出的内容</span></span><br><span class="line">        <span class="comment">// index 为 0 的模块就是 main.js 对应的文件，也就是执行入口模块</span></span><br><span class="line">        <span class="comment">// __webpack_require__.s 的含义是启动模块对应的 index</span></span><br><span class="line">        <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;)(</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的模块都存放在了一个数组里，根据每个模块在数组的 index 来区分和定位模块</span></span><br><span class="line">    [</span><br><span class="line">        <span class="comment">/* 0 */</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 通过 __webpack_require__ 规范导入 show 函数，show.js 对应的模块 index 为 1</span></span><br><span class="line">            <span class="keyword">const</span> show = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 执行 show 函数</span></span><br><span class="line">            show(<span class="string">'Webpack'</span>);</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">/* 1 */</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">window</span>.document.getElementById(<span class="string">'app'</span>).innerText = <span class="string">'Hello,'</span> + content;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过 CommonJS 规范导出 show 函数</span></span><br><span class="line">            <span class="built_in">module</span>.exports = show;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>​    以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 require 语句</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行存放所有模块数组中的第0个模块</span></span><br><span class="line">  __webpack_require__(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;)([<span class="comment">/*存放所有模块的数组*/</span>])</span><br></pre></td></tr></table></figure>
<p>​        <code>bundle.js</code> 能直接运行在浏览器中的原因在于输出的文件中通过 <code>__webpack_require__</code> 函数定义了一个可以在浏览器中执行的加载函数来模拟 Node.js 中的 <code>require</code> 语句。</p>
<p>​        原来一个个独立的模块文件被合并到了一个单独的 <code>bundle.js</code> 的原因在于浏览器不能像 Node.js 那样快速地去本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件。 如果模块数量很多，加载时间会很长，因此把所有模块都存放在了数组中，执行一次网络加载。</p>
<p>​        如果仔细分析 <code>__webpack_require__</code> 函数的实现，你还有发现 Webpack 做了缓存优化： 执行加载过的模块不会再执行第二次，执行结果会缓存在内存中，当某个模块第二次被访问时会直接去内存中读取被缓存的返回值。</p>
<h4 id="分割代码时的输出"><a href="#分割代码时的输出" class="headerlink" title="分割代码时的输出"></a>分割代码时的输出</h4><p>​        例如把源码中的 <code>main.js</code> 修改为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 异步加载 show.js</span><br><span class="line">import(&apos;./show&apos;).then((show) =&gt; &#123;</span><br><span class="line">  // 执行 show 函数</span><br><span class="line">  show(&apos;Webpack&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>​        重新构建后会输出两个文件，分别是执行入口文件 <code>bundle.js</code> 和 异步加载文件 <code>0.bundle.js</code>。</p>
<p>其中 <code>0.bundle.js</code> 内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载在本文件(0.bundle.js)中包含的模块</span></span><br><span class="line">webpackJsonp(</span><br><span class="line">  <span class="comment">// 在其它文件中存放着的模块的 ID</span></span><br><span class="line">  [<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 本文件所包含的模块</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// show.js 所对应的模块</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.document.getElementById(<span class="string">'app'</span>).innerText = <span class="string">'Hello,'</span> + content;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">module</span>.exports = show;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>bundle.js</code> 内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * webpackJsonp 用于从异步加载的文件中安装模块。</span></span><br><span class="line"><span class="comment">   * 把 webpackJsonp 挂载到全局是为了方便在其它文件中调用。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param chunkIds 异步加载的文件中存放的需要安装的模块对应的 Chunk ID</span></span><br><span class="line"><span class="comment">   * @param moreModules 异步加载的文件中存放的需要安装的模块列表</span></span><br><span class="line"><span class="comment">   * @param executeModules 在异步加载的文件中存放的需要安装的模块都安装成功后，需要执行的模块对应的 index</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">window</span>[<span class="string">"webpackJsonp"</span>] = <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">chunkIds, moreModules, executeModules</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把 moreModules 添加到 modules 对象中</span></span><br><span class="line">    <span class="comment">// 把所有 chunkIds 对应的模块都标记成已经加载成功 </span></span><br><span class="line">    <span class="keyword">var</span> moduleId, chunkId, i = <span class="number">0</span>, resolves = [], result;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">      chunkId = chunkIds[i];</span><br><span class="line">      <span class="keyword">if</span> (installedChunks[chunkId]) &#123;</span><br><span class="line">        resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      installedChunks[chunkId] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">        modules[moduleId] = moreModules[moduleId];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (resolves.length) &#123;</span><br><span class="line">      resolves.shift()();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存已经安装的模块</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储每个 Chunk 的加载状态；</span></span><br><span class="line">  <span class="comment">// 键为 Chunk 的 ID，值为0代表已经加载成功</span></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 require 语句，和上面介绍的一致</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略和上面一样的内容</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件</span></span><br><span class="line"><span class="comment">   * @param chunkId 需要异步加载的 Chunk 对应的 ID</span></span><br><span class="line"><span class="comment">   * @returns &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  __webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从上面定义的 installedChunks 中获取 chunkId 对应的 Chunk 的加载状态</span></span><br><span class="line">    <span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line">    <span class="comment">// 如果加载状态为0表示该 Chunk 已经加载成功了，直接返回 resolve Promise</span></span><br><span class="line">    <span class="keyword">if</span> (installedChunkData === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// installedChunkData 不为空且不为0表示该 Chunk 正在网络加载中</span></span><br><span class="line">    <span class="keyword">if</span> (installedChunkData) &#123;</span><br><span class="line">      <span class="comment">// 返回存放在 installedChunkData 数组中的 Promise 对象</span></span><br><span class="line">      <span class="keyword">return</span> installedChunkData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// installedChunkData 为空，表示该 Chunk 还没有加载过，去加载该 Chunk 对应的文件</span></span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">    &#125;);</span><br><span class="line">    installedChunkData[<span class="number">2</span>] = promise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 DOM 操作，往 HTML head 中插入一个 script 标签去异步加载 Chunk 对应的 JavaScript 文件</span></span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.charset = <span class="string">'utf-8'</span>;</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    script.timeout = <span class="number">120000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件的路径为配置的 publicPath、chunkId 拼接而成</span></span><br><span class="line">    script.src = __webpack_require__.p + <span class="string">""</span> + chunkId + <span class="string">".bundle.js"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置异步加载的最长超时时间</span></span><br><span class="line">    <span class="keyword">var</span> timeout = setTimeout(onScriptComplete, <span class="number">120000</span>);</span><br><span class="line">    script.onerror = script.onload = onScriptComplete;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 script 加载和执行完成时回调</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onScriptComplete</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 防止内存泄露</span></span><br><span class="line">      script.onerror = script.onload = <span class="literal">null</span>;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 去检查 chunkId 对应的 Chunk 是否安装成功，安装成功时才会存在于 installedChunks 中</span></span><br><span class="line">      <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line">      <span class="keyword">if</span> (chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chunk) &#123;</span><br><span class="line">          chunk[<span class="number">1</span>](<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Loading chunk '</span> + chunkId + <span class="string">' failed.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载并执行入口模块，和上面介绍的一致</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(</span><br><span class="line">  <span class="comment">// 存放所有没有经过异步加载的，随着执行入口文件加载的模块</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// main.js 对应的模块</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 通过 __webpack_require__.e 去异步加载 show.js 对应的 Chunk</span></span><br><span class="line">      __webpack_require__.e(<span class="number">0</span>).then(__webpack_require__.bind(<span class="literal">null</span>, <span class="number">1</span>)).then(<span class="function">(<span class="params">show</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 show 函数</span></span><br><span class="line">        show(<span class="string">'Webpack'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>bundle.js</code> 和上面所讲的 <code>bundle.js</code> 非常相似，区别在于：</p>
<ul>
<li>多了一个 <code>__webpack_require__.e</code> 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件;</li>
<li>多了一个 <code>webpackJsonp</code> 函数用于从异步加载的文件中安装模块。</li>
</ul>
<p>在使用了 <code>CommonsChunkPlugin</code> 去提取公共代码时输出的文件和使用了异步加载时输出的文件是一样的，都会有 <code>__webpack_require__.e</code> 和 <code>webpackJsonp</code>。 原因在于提取公共代码和异步加载本质上都是代码分割。</p>
<h3 id="编写Loader"><a href="#编写Loader" class="headerlink" title="编写Loader"></a>编写Loader</h3><h4 id="Loader的职责"><a href="#Loader的职责" class="headerlink" title="Loader的职责"></a>Loader的职责</h4><p>​        由上面的例子可以看出：一个 Loader 的职责是单一的，只需要完成一种转换。 如果一个源文件需要经历多步转换才能正常使用，就通过多个 Loader 去转换。 在调用多个 Loader 去转换一个文件时，每个 Loader 会链式的顺序执行， 第一个 Loader 将会拿到需处理的原内容，上一个 Loader 处理后的结果会传给下一个接着处理，最后的 Loader 将处理后的最终结果返回给 Webpack。</p>
<p>​        所以，在你开发一个 Loader 时，请保持其职责的单一性，你只需关心输入和输出。</p>
<h4 id="Loader基础"><a href="#Loader基础" class="headerlink" title="Loader基础"></a>Loader基础</h4><p>​        由于 Webpack 是运行在 Node.js 之上的，一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数。 这个导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。</p>
<p>​        一个最简单的 Loader 的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// source 为 compiler 传递给 Loader 的一个文件的原内容</span></span><br><span class="line">  <span class="comment">// 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换</span></span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        由于 Loader 运行在 Node.js 中，你可以调用任何 Node.js 自带的 API，或者安装第三方模块进行调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'node-sass'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sass(source);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Loader进阶"><a href="#Loader进阶" class="headerlink" title="Loader进阶"></a>Loader进阶</h4><p>​        以上只是个最简单的 Loader，Webpack 还提供一些 API 供 Loader 调用，下面来一一介绍。</p>
<h5 id="获得Loader的options"><a href="#获得Loader的options" class="headerlink" title="获得Loader的options"></a>获得Loader的options</h5><p>​        在最上面处理 SCSS 文件的 Webpack 配置中，给 <code>css-loader</code> 传了 <code>options</code> 参数，以控制 <code>css-loader</code>。 如何在自己编写的 Loader 中获取到用户传入的 <code>options</code> 呢？需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取到用户给当前 Loader 传入的 options</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="返回其他结果"><a href="#返回其他结果" class="headerlink" title="返回其他结果"></a>返回其他结果</h5><p>上面的 Loader 都只是返回了原内容转换后的内容，但有些场景下还需要返回除了内容之外的东西。</p>
<p>例如以用 <code>babel-loader</code> 转换 ES6 代码为例，它还需要输出转换后的 ES5 代码对应的 Source Map，以方便调试源码。 为了把 Source Map 也一起随着 ES5 代码返回给 Webpack，可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 this.callback 告诉 Webpack 返回的结果</span></span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, source, sourceMaps);</span><br><span class="line">  <span class="comment">// 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，</span></span><br><span class="line">  <span class="comment">// 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 </span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        其中的 <code>this.callback</code> 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。 <code>this.callback</code> 的详细使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.callback(</span><br><span class="line">    <span class="comment">// 当无法转换原内容时，给 Webpack 返回一个 Error</span></span><br><span class="line">    err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 原内容转换后的内容</span></span><br><span class="line">    content: string | Buffer,</span><br><span class="line">    <span class="comment">// 用于把转换后的内容得出原内容的 Source Map，方便调试</span></span><br><span class="line">    sourceMap?: SourceMap,</span><br><span class="line">    <span class="comment">// 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回，</span></span><br><span class="line">    <span class="comment">// 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能</span></span><br><span class="line">    abstractSyntaxTree?: AST</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>​        Source Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。 为此 Webpack 为 Loader 提供了 <code>this.sourceMap</code> API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。 如果你编写的 Loader 会生成 Source Map，请考虑到这点。</p>
</blockquote>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>​        Loader 有同步和异步之分，上面介绍的 Loader 都是同步的 Loader，因为它们的转换流程都是同步的，转换完成后再返回结果。 但在有些场景下转换的步骤只能是异步完成的，例如你需要通过网络请求才能得出结果，如果采用同步的方式网络请求就会阻塞整个构建，导致构建非常缓慢。</p>
<p>​        在转换步骤是异步时，你可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果</span></span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    someAsyncOperation(source, <span class="function"><span class="keyword">function</span>(<span class="params">err, result, sourceMaps, ast</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 callback 返回异步执行后的结果</span></span><br><span class="line">        callback(err, result, sourceMaps, ast);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="处理二进制数据"><a href="#处理二进制数据" class="headerlink" title="处理二进制数据"></a>处理二进制数据</h4><p>​        在默认的情况下，Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。 但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，例如 <code>file-loader</code>，就需要 Webpack 给 Loader 传入二进制格式的数据。 为此，你需要这样编写 Loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123;</span><br><span class="line">    // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的</span><br><span class="line">    source instanceof Buffer === true;</span><br><span class="line">    // Loader 返回的类型也可以是 Buffer 类型的</span><br><span class="line">    // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果</span><br><span class="line">    return source;</span><br><span class="line">&#125;;</span><br><span class="line">// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 </span><br><span class="line">module.exports.raw = true;</span><br></pre></td></tr></table></figure>
<p>​        以上代码中最关键的代码是最后一行 <code>module.exports.raw = true;</code>，没有该行 Loader 只能拿到字符串。</p>
<h4 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h4><p>在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。 为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时， 是不会重新调用对应的 Loader 去执行转换操作的。</p>
<p>如果你想让 Webpack 不缓存该 Loader 的处理结果，可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 关闭该 Loader 的缓存功能</span></span><br><span class="line">  <span class="keyword">this</span>.cacheable(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="其他Loader-API"><a href="#其他Loader-API" class="headerlink" title="其他Loader API"></a>其他Loader API</h4><p>除了以上提到的在 Loader 中能调用的 Webpack API 外，还存在以下常用 API：</p>
<ul>
<li><code>this.context</code>：当前处理文件的所在目录，假如当前 Loader 处理的文件是 <code>/src/main.js</code>，则 <code>this.context</code> 就等于 <code>/src</code>。</li>
<li><code>this.resource</code>：当前处理文件的完整请求路径，包括 <code>querystring</code>，例如 <code>/src/main.js?name=1</code>。</li>
<li><code>this.resourcePath</code>：当前处理文件的路径，例如 <code>/src/main.js</code>。</li>
<li><code>this.resourceQuery</code>：当前处理文件的 <code>querystring</code>。</li>
<li><code>this.target</code>：等于 Webpack 配置中的 Target。</li>
<li><code>this.loadModule</code>：但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 <code>this.loadModule(request: string, callback: function(err, source, sourceMap, module))</code> 去获得 <code>request</code> 对应文件的处理结果。</li>
<li><code>this.resolve</code>：像 <code>require</code> 语句一样获得指定文件的完整路径，使用方法为 <code>resolve(context: string, request: string, callback: function(err, result: string))</code>。</li>
<li><code>this.addDependency</code>：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 <code>addDependency(file: string)</code>。</li>
<li><code>this.addContextDependency</code>：和 <code>addDependency</code> 类似，但 <code>addContextDependency</code> 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 <code>addContextDependency(directory: string)</code>。</li>
<li><code>this.clearDependencies</code>：清除当前正在处理文件的所有依赖，使用方法为 <code>clearDependencies()</code>。</li>
<li><code>this.emitFile</code>：输出一个文件，使用方法为 <code>emitFile(name: string, content: Buffer|string, sourceMap: {...})</code>。</li>
</ul>
<h4 id="加载本地Loader"><a href="#加载本地Loader" class="headerlink" title="加载本地Loader"></a>加载本地Loader</h4><p>​        在开发 Loader 的过程中，为了测试编写的 Loader 是否能正常工作，需要把它配置到 Webpack 中后，才可能会调用该 Loader。 在前面的章节中，使用的 Loader 都是通过 Npm 安装的，要使用 Loader 时会直接使用 Loader 的名称，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果还采取以上的方法去使用本地开发的 Loader 将会很麻烦，因为你需要确保编写的 Loader 的源码是在 <code>node_modules</code>目录下。 为此你需要先把编写的 Loader 发布到 Npm 仓库后再安装到本地项目使用。</p>
<p>解决以上问题的便捷方法有两种，分别如下：</p>
<h5 id="Npm-link"><a href="#Npm-link" class="headerlink" title="Npm link"></a>Npm link</h5><p>Npm link 专门用于开发和调试本地 Npm 模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 <code>node_modules</code> 目录下，让项目可以直接使用本地的 Npm 模块。 由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。</p>
<p>完成 Npm link 的步骤如下：</p>
<ul>
<li>确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 <code>package.json</code> 已经正确配置好；</li>
<li>在本地 Npm 模块根目录下执行 <code>npm link</code>，把本地模块注册到全局；</li>
<li>在项目根目录下执行 <code>npm link loader-name</code>，把第2步注册到全局的本地 Npm 模块链接到项目的 <code>node_moduels</code>下，其中的 <code>loader-name</code> 是指在第1步中的 <code>package.json</code> 文件中配置的模块名称。</li>
</ul>
<p>链接好 Loader 到项目后你就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了。</p>
<h5 id="ResolveLoader"><a href="#ResolveLoader" class="headerlink" title="ResolveLoader"></a>ResolveLoader</h5><p>​        ResolveLoader 用于配置 Webpack 如何寻找 Loader。 默认情况下只会去 <code>node_modules</code> 目录下寻找，为了让 Webpack 加载放在本地项目中的 Loader 需要修改 <code>resolveLoader.modules</code>。</p>
<p>假如本地的 Loader 在项目目录中的 <code>./loaders/loader-name</code> 中，则需要如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  resolveLoader:&#123;</span><br><span class="line">    // 去哪些目录下寻找 Loader，有先后顺序之分</span><br><span class="line">    modules: [&apos;node_modules&apos;,&apos;./loaders/&apos;],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        加上以上配置后， Webpack 会先去 <code>node_modules</code> 项目下寻找 Loader，如果找不到，会再去 <code>./loaders/</code>目录下寻找。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>上面讲了许多理论，接下来从实际出发，来编写一个解决实际问题的 Loader。</p>
<p>该 Loader 名叫 <code>comment-require-loader</code>，作用是把 JavaScript 代码中的注释语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @require '../style/index.css'</span></span><br></pre></td></tr></table></figure>
<p>转换成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'../style/index.css'</span>);</span><br></pre></td></tr></table></figure>
<p>该 Loader 的使用场景是去正确加载针对 <a href="http://fis.baidu.com/fis3/docs/user-dev/require.html" target="_blank" rel="noopener">Fis3</a> 编写的 JavaScript，这些 JavaScript 中存在通过注释的方式加载依赖的 CSS 文件。</p>
<p>该 Loader 的使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'comment-require-loader'</span>],</span><br><span class="line">        <span class="comment">// 针对采用了 fis3 CSS 导入语法的 JavaScript 文件通过 comment-require-loader 去转换 </span></span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'node_modules/imui'</span>)]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该 Loader 的实现非常简单，完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用正则把 // @require '../style/index.css' 转换成 require('../style/index.css');  </span></span><br><span class="line">    <span class="keyword">return</span> source.replace(<span class="regexp">/(\/\/ *@require) +(('|").+('|")).*/</span>, <span class="string">'require($2);'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replace(content);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="编写Plugin"><a href="#编写Plugin" class="headerlink" title="编写Plugin"></a>编写Plugin</h3><p>​        Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<p>一个最基础的 Plugin 的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class BasicPlugin&#123;</span><br><span class="line">  // 在构造函数中获取用户给该插件传入的配置</span><br><span class="line">  constructor(options)&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span><br><span class="line">  apply(compiler)&#123;</span><br><span class="line">    compiler.plugin(&apos;compilation&apos;,function(compilation) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出 Plugin</span><br><span class="line">module.exports = BasicPlugin;</span><br></pre></td></tr></table></figure>
<p>​        在使用这个 Plugin 时，相关配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const BasicPlugin = require(&apos;./BasicPlugin.js&apos;);</span><br><span class="line">module.export = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    new BasicPlugin(options),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        Webpack 启动后，在读取配置的过程中会先执行 <code>new BasicPlugin(options)</code> 初始化一个 <code>BasicPlugin</code> 获得其实例。 在初始化 <code>compiler</code> 对象后，再调用 <code>basicPlugin.apply(compiler)</code> 给插件实例传入 <code>compiler</code> 对象。 插件实例在获取到 <code>compiler</code> 对象后，就可以通过 <code>compiler.plugin(事件名称, 回调函数)</code> 监听到 Webpack 广播出来的事件。 并且可以通过 <code>compiler</code> 对象去操作 Webpack。</p>
<p>​        通过以上最简单的 Plugin 相信你大概明白了 Plugin 的工作原理，但实际开发中还有很多细节需要注意，下面来详细介绍。</p>
<h4 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a><code>Compiler</code> 和 <code>Compilation</code></h4><p>在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation，它们是 Plugin 和 Webpack 之间的桥梁。 Compiler 和 Compilation 的含义如下：</p>
<ul>
<li>Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 <code>options</code>，<code>loaders</code>，<code>plugins</code> 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</li>
<li>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</li>
</ul>
<p>Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p>
<h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</p>
<p>Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p>
<p>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 广播出事件</span></span><br><span class="line"><span class="comment">* event-name 为事件名称，注意不要和现有的事件重名</span></span><br><span class="line"><span class="comment">* params 为附带的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>,params);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。</span></span><br><span class="line"><span class="comment">* 同时函数中的 params 参数为广播事件时附带的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同理，<code>compilation.apply</code> 和 <code>compilation.plugin</code> 使用方法和上面一致。</p>
<p>在开发插件时，你可能会不知道该如何下手，因为你不知道该监听哪个事件才能完成任务。</p>
<p>在开发插件时，还需要注意以下两点：</p>
<ul>
<li>只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。</li>
<li>传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。</li>
<li>有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">compilation, callback</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 支持处理逻辑</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理完毕后执行 callback 以通知 Webpack </span></span><br><span class="line">   <span class="comment">// 如果不执行 callback，运行流程将会一直卡在这不往下执行 </span></span><br><span class="line">   callback();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>​        插件可以用来修改输出文件、增加输出文件、甚至可以提升 Webpack 性能、等等，总之插件通过调用 Webpack 提供的 API 能完成很多事情。 由于 Webpack 提供的 API 非常多，有很多 API 很少用的上，又加上篇幅有限，下面来介绍一些常用的 API。</p>
<h5 id="读取输出资源、代码块、模块及其依赖"><a href="#读取输出资源、代码块、模块及其依赖" class="headerlink" title="读取输出资源、代码块、模块及其依赖"></a>读取输出资源、代码块、模块及其依赖</h5><p>​        有些插件可能需要读取 Webpack 的处理结果，例如输出资源、代码块、模块及其依赖，以便做下一步处理。</p>
<p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。 插件代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// compilation.chunks 存放所有代码块，是一个数组</span></span><br><span class="line">      compilation.chunks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// chunk 代表一个代码块</span></span><br><span class="line">        <span class="comment">// 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块</span></span><br><span class="line">        chunk.forEachModule(<span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// module 代表一个模块</span></span><br><span class="line">          <span class="comment">// module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组</span></span><br><span class="line">          <span class="built_in">module</span>.fileDependencies.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filepath</span>) </span>&#123;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件</span></span><br><span class="line">        <span class="comment">// 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时，</span></span><br><span class="line">        <span class="comment">// 该 Chunk 就会生成 .js 和 .css 两个文件</span></span><br><span class="line">        chunk.files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// compilation.assets 存放当前所有即将输出的资源</span></span><br><span class="line">          <span class="comment">// 调用一个输出资源的 source() 方法能获取到输出资源的内容</span></span><br><span class="line">          <span class="keyword">let</span> source = compilation.assets[filename].source();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。</span></span><br><span class="line">      <span class="comment">// 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="监听文件变化"><a href="#监听文件变化" class="headerlink" title="监听文件变化"></a>监听文件变化</h5><p>​        Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时， 就会触发一次新的 Compilation。</p>
<p>在开发插件时经常需要知道是哪个文件发生变化导致了新的 Compilation，为此可以使用如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当依赖的文件发生变化时会触发 watch-run 事件</span></span><br><span class="line">compiler.plugin(<span class="string">'watch-run'</span>, (watching, callback) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取发生变化的文件列表</span></span><br><span class="line">    <span class="keyword">const</span> changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;</span><br><span class="line">    <span class="comment">// changedFiles 格式为键值对，键为发生变化的文件路径。</span></span><br><span class="line">    <span class="keyword">if</span> (changedFiles[filePath] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// filePath 对应的文件发生了变化</span></span><br><span class="line">    &#125;</span><br><span class="line">    callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>​        默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。 由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。 为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'after-compile'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译</span></span><br><span class="line">    compilation.fileDependencies.push(filePath);</span><br><span class="line">    callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="修改输出资源"><a href="#修改输出资源" class="headerlink" title="修改输出资源"></a>修改输出资源</h5><p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 <code>emit</code> 事件，因为发生 <code>emit</code> 事件时所有模块的转换和代码块对应的文件已经生成好， 需要输出的资源即将输出，因此 <code>emit</code> 事件是修改 Webpack 输出资源的最后时机。</p>
<p>所有需要输出的资源会存放在 <code>compilation.assets</code> 中，<code>compilation.assets</code> 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。</p>
<p>设置 <code>compilation.assets</code> 的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置名称为 fileName 的输出资源</span></span><br><span class="line">  compilation.assets[fileName] = &#123;</span><br><span class="line">    <span class="comment">// 返回文件内容</span></span><br><span class="line">    source: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer</span></span><br><span class="line">      <span class="keyword">return</span> fileContent;</span><br><span class="line">      &#125;,</span><br><span class="line">    <span class="comment">// 返回文件大小</span></span><br><span class="line">      size: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Buffer.byteLength(fileContent, <span class="string">'utf8'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>读取 <code>compilation.assets</code> 的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取名称为 fileName 的输出资源</span></span><br><span class="line">  <span class="keyword">const</span> asset = compilation.assets[fileName];</span><br><span class="line">  <span class="comment">// 获取输出资源的内容</span></span><br><span class="line">  asset.source();</span><br><span class="line">  <span class="comment">// 获取输出资源的文件大小</span></span><br><span class="line">  asset.size();</span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="判断Webpack使用了哪些插件"><a href="#判断Webpack使用了哪些插件" class="headerlink" title="判断Webpack使用了哪些插件"></a>判断Webpack使用了哪些插件</h5><p>在开发一个插件时可能需要根据当前配置是否使用了其它某个插件而做下一步决定，因此需要读取 Webpack 当前的插件配置情况。 以判断当前是否使用了 ExtractTextPlugin 为例，可以使用如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前配置使用使用了 ExtractTextPlugin，</span></span><br><span class="line"><span class="comment">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasExtractTextPlugin</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前配置所有使用的插件列表</span></span><br><span class="line">  <span class="keyword">const</span> plugins = compiler.options.plugins;</span><br><span class="line">  <span class="comment">// 去 plugins 中寻找有没有 ExtractTextPlugin 的实例</span></span><br><span class="line">  <span class="keyword">return</span> plugins.find(<span class="function"><span class="params">plugin</span>=&gt;</span>plugin.__proto__.constructor === ExtractTextPlugin) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><p>下面我们举一个实际的例子，带你一步步去实现一个插件。</p>
<p>该插件的名称取名叫 EndWebpackPlugin，作用是在 Webpack 即将退出时再附加一些额外的操作，例如在 Webpack 成功编译和输出了文件后执行发布操作把输出的文件上传到服务器。 同时该插件还能区分 Webpack 构建是否执行成功。使用该插件时方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="comment">// 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数；</span></span><br><span class="line">    <span class="keyword">new</span> EndWebpackPlugin(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作</span></span><br><span class="line">    &#125;, (err) =&gt; &#123;</span><br><span class="line">      <span class="comment">// Webpack 构建失败，err 是导致错误的原因</span></span><br><span class="line">      <span class="built_in">console</span>.error(err);        </span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现该插件，需要借助两个事件：</p>
<ul>
<li><code>done</code>：在成功构建并且输出了文件后，Webpack 即将退出时发生；</li>
<li><code>failed</code>：在构建出现异常导致构建失败，Webpack 即将退出时发生；</li>
</ul>
<p>实现该插件非常简单，完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndWebpackPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(doneCallback, failCallback) &#123;</span><br><span class="line">    <span class="comment">// 存下在构造函数中传入的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.doneCallback = doneCallback;</span><br><span class="line">    <span class="keyword">this</span>.failCallback = failCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">'done'</span>, (stats) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在 done 事件中回调 doneCallback</span></span><br><span class="line">        <span class="keyword">this</span>.doneCallback(stats);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.plugin(<span class="string">'failed'</span>, (err) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在 failed 事件中回调 failCallback</span></span><br><span class="line">        <span class="keyword">this</span>.failCallback(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出插件 </span></span><br><span class="line"><span class="built_in">module</span>.exports = EndWebpackPlugin;</span><br></pre></td></tr></table></figure>
<p>从开发这个插件可以看出，找到合适的事件点去完成功能在开发插件时显得尤为重要。 在 <strong>工作原理概括</strong> 中详细介绍过 Webpack 在运行过程中广播出常用事件，你可以从中找到你需要的事件。</p>
<h3 id="调试Webpack"><a href="#调试Webpack" class="headerlink" title="调试Webpack"></a>调试Webpack</h3><p>​        在编写 Webpack 的 Plugin 和 Loader 时，可能执行结果会和你预期的不一样，就和你平时写代码遇到了奇怪的 Bug 一样。 对于无法一眼看出问题的 Bug，通常需要调试程序源码才能找出问题所在。</p>
<p>​        虽然可以通过 <code>console.log</code> 的方式完成调试，但这种方法非常不方便也不优雅，本节将教你如何断点调试 <strong>工作原理概括</strong> 中的插件代码。 由于 Webpack 运行在 Node.js 之上，调试 Webpack 就相对于调试 Node.js 程序。</p>
<h4 id="在Webstorm中调试"><a href="#在Webstorm中调试" class="headerlink" title="在Webstorm中调试"></a>在Webstorm中调试</h4><p>Webstorm 集成了 Node.js 的调试工具，因此使用 Webstorm 调试 Webpack 非常简单。</p>
<h5 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h5><p>在你认为可能出现问题的地方设下断点，点击编辑区代码左侧出现红点表示设置了断点。</p>
<h5 id="配置执行入口"><a href="#配置执行入口" class="headerlink" title="配置执行入口"></a>配置执行入口</h5><p>告诉 Webstorm 如何启动 Webpack，由于 Webpack 实际上就是一个 Node.js 应用，因此需要新建一个 Node.js 类型的执行入口。</p>
<p>以上配置中有三点需要注意：</p>
<ul>
<li><code>Name</code> 设置成了 <code>debug webpack</code>，就像设置了一个别名，方便记忆和区分；</li>
<li><code>Working directory</code> 设置为需要调试的插件所在的项目的根目录；</li>
<li><code>JavaScript file</code> 即 Node.js 的执行入口文件，设置为 Webpack 的执行入口文件 <code>node_modules/webpack/bin/webpack.js</code>。</li>
</ul>
<h5 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h5><p>经过以上两步，准备工作已经完成，下面启动调试，启动时选中前面设置的 <code>debug webpack</code>。</p>
<h5 id="执行到断点"><a href="#执行到断点" class="headerlink" title="执行到断点"></a>执行到断点</h5><p>启动后程序就会停在断点所在的位置，在这里你可以方便的查看变量当前的状态，找出问题。</p>
<h3 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h3><p>​        Webpack 是一个庞大的 Node.js 应用，如果你阅读过它的源码，你会发现实现一个完整的 Webpack 需要编写非常多的代码。 但你无需了解所有的细节，只需了解其整体架构和部分细节即可。</p>
<p>​        对 Webpack 的使用者来说，它是一个简单强大的工具； 对 Webpack 的开发者来说，它是一个扩展性的高系统。</p>
<p>​        Webpack 之所以能成功，在于它把复杂的实现隐藏了起来，给用户暴露出的只是一个简单的工具，让用户能快速达成目的。 同时整体架构设计合理，扩展性高，开发扩展难度不高，通过社区补足了大量缺失的功能，让 Webpack 几乎能胜任任何场景。</p>
<p>​        通过本章的学习，希望你不仅能学会如何编写 Webpack 扩展，也能从中领悟到如何设计好的系统架构。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/webpack/" rel="tag"># webpack</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/15/Vue中有趣的自定义指令/" rel="next" title="Vue中有趣的自定义指令">
                <i class="fa fa-chevron-left"></i> Vue中有趣的自定义指令
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/18/Webpack初体验/" rel="prev" title="Webpack初体验">
                Webpack初体验 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8" alt="Siir">
            
              <p class="site-author-name" itemprop="name">Siir</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">108</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">Kategorien</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">205</span>
                    <span class="site-state-item-name">schlagwörter</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/burning-shadow" title="GitHub &rarr; https://github.com/burning-shadow" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/6975656937" title="Weibo &rarr; https://weibo.com/6975656937" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#是什么"><span class="nav-number">1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几个概念"><span class="nav-number">2.</span> <span class="nav-text">几个概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程"><span class="nav-number">3.</span> <span class="nav-text">流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概括"><span class="nav-number">3.1.</span> <span class="nav-text">概括</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#细节"><span class="nav-number">3.2.</span> <span class="nav-text">细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化阶段"><span class="nav-number">3.3.</span> <span class="nav-text">初始化阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译阶段"><span class="nav-number">3.4.</span> <span class="nav-text">编译阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出阶段"><span class="nav-number">3.5.</span> <span class="nav-text">输出阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出文件分析"><span class="nav-number">4.</span> <span class="nav-text">输出文件分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分割代码时的输出"><span class="nav-number">4.1.</span> <span class="nav-text">分割代码时的输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写Loader"><span class="nav-number">5.</span> <span class="nav-text">编写Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Loader的职责"><span class="nav-number">5.1.</span> <span class="nav-text">Loader的职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Loader基础"><span class="nav-number">5.2.</span> <span class="nav-text">Loader基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Loader进阶"><span class="nav-number">5.3.</span> <span class="nav-text">Loader进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#获得Loader的options"><span class="nav-number">5.3.1.</span> <span class="nav-text">获得Loader的options</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#返回其他结果"><span class="nav-number">5.3.2.</span> <span class="nav-text">返回其他结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步与异步"><span class="nav-number">5.4.</span> <span class="nav-text">同步与异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理二进制数据"><span class="nav-number">5.5.</span> <span class="nav-text">处理二进制数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存加速"><span class="nav-number">5.6.</span> <span class="nav-text">缓存加速</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他Loader-API"><span class="nav-number">5.7.</span> <span class="nav-text">其他Loader API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加载本地Loader"><span class="nav-number">5.8.</span> <span class="nav-text">加载本地Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Npm-link"><span class="nav-number">5.8.1.</span> <span class="nav-text">Npm link</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ResolveLoader"><span class="nav-number">5.8.2.</span> <span class="nav-text">ResolveLoader</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实战"><span class="nav-number">5.9.</span> <span class="nav-text">实战</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写Plugin"><span class="nav-number">6.</span> <span class="nav-text">编写Plugin</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Compiler-和-Compilation"><span class="nav-number">6.1.</span> <span class="nav-text">Compiler 和 Compilation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件流"><span class="nav-number">6.2.</span> <span class="nav-text">事件流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用API"><span class="nav-number">6.3.</span> <span class="nav-text">常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#读取输出资源、代码块、模块及其依赖"><span class="nav-number">6.3.1.</span> <span class="nav-text">读取输出资源、代码块、模块及其依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#监听文件变化"><span class="nav-number">6.3.2.</span> <span class="nav-text">监听文件变化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修改输出资源"><span class="nav-number">6.3.3.</span> <span class="nav-text">修改输出资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#判断Webpack使用了哪些插件"><span class="nav-number">6.3.4.</span> <span class="nav-text">判断Webpack使用了哪些插件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实战-1"><span class="nav-number">6.4.</span> <span class="nav-text">实战</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试Webpack"><span class="nav-number">7.</span> <span class="nav-text">调试Webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在Webstorm中调试"><span class="nav-number">7.1.</span> <span class="nav-text">在Webstorm中调试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设置断点"><span class="nav-number">7.1.1.</span> <span class="nav-text">设置断点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#配置执行入口"><span class="nav-number">7.1.2.</span> <span class="nav-text">配置执行入口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#启动调试"><span class="nav-number">7.1.3.</span> <span class="nav-text">启动调试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#执行到断点"><span class="nav-number">7.1.4.</span> <span class="nav-text">执行到断点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理总结"><span class="nav-number">8.</span> <span class="nav-text">原理总结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Siir</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
