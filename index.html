<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/siir.jpg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/siir.jpg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/siir.jpg?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Siir">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Siir">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Siir">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Siir</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Siir</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Schlagwörter</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Kategorien</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/实现一个Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/29/实现一个Promise/" class="post-title-link" itemprop="url">实现一个Promise</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-29 16:16:47" itemprop="dateCreated datePublished" datetime="2019-03-29T16:16:47+08:00">2019-03-29</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript-——-原理篇/" itemprop="url" rel="index"><span itemprop="name">JavaScript —— 原理篇</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>利用ES5实现<code>Promise</code></p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/29/实现一个Promise/#more" rel="contents">
                Weiterlesen &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/实现bind、call和apply/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/实现bind、call和apply/" class="post-title-link" itemprop="url">实现bind、call和apply</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 20:25:24" itemprop="dateCreated datePublished" datetime="2019-03-28T20:25:24+08:00">2019-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-03-29 16:18:59" itemprop="dateModified" datetime="2019-03-29T16:18:59+08:00">2019-03-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript-——-原理篇/" itemprop="url" rel="index"><span itemprop="name">JavaScript —— 原理篇</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>对<code>call</code>、<code>bind</code>和<code>apply</code>三个库函数的实现</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/28/实现bind、call和apply/#more" rel="contents">
                Weiterlesen &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/JavaScript中的多继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/JavaScript中的多继承/" class="post-title-link" itemprop="url">JavaScript中的多继承&多态</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 19:22:03 / Geändert am: 19:33:12" itemprop="dateCreated datePublished" datetime="2019-03-28T19:22:03+08:00">2019-03-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript设计模式/" itemprop="url" rel="index"><span itemprop="name">JavaScript设计模式</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>理论上讲，<code>JavaScript</code>中继承是依赖于原型<code>prototype</code>链实现继承的。由于只有一条链所以理论上讲无法实现多继承。但是我们可以另辟蹊径</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/28/JavaScript中的多继承/#more" rel="contents">
                Weiterlesen &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/JavaScript中的封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/JavaScript中的封装/" class="post-title-link" itemprop="url">JavaScript中的封装</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 16:43:51 / Geändert am: 18:42:49" itemprop="dateCreated datePublished" datetime="2019-03-28T16:43:51+08:00">2019-03-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript设计模式/" itemprop="url" rel="index"><span itemprop="name">JavaScript设计模式</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在面向对象语言中会有各式各样的关键字，如<code>public</code>、<code>pcivate</code>、<code>protected</code>、<code>static</code>等等，设置了属性和方法的权限。</p>
<p>作为一门弱类型语言<code>JavaScript</code>显然不具备这样的确定权限关键字，所以我们采取了另外的方式来使得变量和方法的权限得以被区别开来</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/28/JavaScript中的封装/#more" rel="contents">
                Weiterlesen &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/十五、HTTPS协议：点外卖的过程原来这么复杂/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/十五、HTTPS协议：点外卖的过程原来这么复杂/" class="post-title-link" itemprop="url">十五、HTTPS协议：点外卖的过程原来这么复杂</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 11:13:58 / Geändert am: 11:14:30" itemprop="dateCreated datePublished" datetime="2019-03-28T11:13:58+08:00">2019-03-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用 HTTP 协议，看个新闻还没有问题，但是换到更加严肃的场景中，就存在很多的安全风险。例如，你要下单做一次支付，如果还是使用普通的 HTTP 协议，那你很可能会被黑客盯上。</p>

<p>你发送一个请求，说我要点个外卖，但是这个网络包被截获了，于是在服务器回复你之前，黑客先假装自己就是外卖网站，然后给你回复一个假的消息说：“好啊好啊，来来来，银行卡号、密码拿来。”如果这时候你真把银行卡密码发给它，那你就真的上套了。</p><br><p>那怎么解决这个问题呢？当然一般的思路就是<font size="3" color="red">加密</font>。加密分为两种方式一种是<font size="3" color="red">对称加密</font>，一种是<font size="3" color="red">非对称加密</font>。</p>

<p>在对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。</p>

<p>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。</p><br><p>因为对称加密算法相比非对称加密算法来说，效率要高得多，性能也好，所以<font size="3" color="red">交互的场景下多用对称加密。</font></p>

<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>假设你和外卖网站约定了一个密钥，你发送请求的时候用这个密钥进行加密，外卖网站用同样的密钥进行解密。这样就算中间的黑客截获了你的请求，但是它没有密钥，还是破解不了。</p><!-- [[[read_end]]] --><br><p>这看起来很完美，但是中间有个问题，你们两个怎么来约定这个密钥呢？如果这个密钥在互联网上传输，也是很有可能让黑客截获的。黑客一旦截获这个秘钥，它可以佯作不知，静静地等着你们两个交互。这时候你们之间互通的任何消息，它都能截获并且查看，就等你把银行卡账号和密码发出来。</p>

<p>我们在谍战剧里面经常看到这样的场景，就是特工破译的密码会有个密码本，截获无线电台，通过密码本就能将原文破解出来。怎么把密码本给对方呢？只能通过<font size="3" color="red">线下传输</font>。</p><br><p>比如，你和外卖网站偷偷约定时间地点，它给你一个纸条，上面写着你们两个的密钥，然后说以后就用这个密钥在互联网上定外卖了。当然你们接头的时候，也会先约定一个口号，什么“天王盖地虎”之类的，口号对上了，才能把纸条给它。但是，“天王盖地虎”同样也是对称加密密钥，同样存在如何把“天王盖地虎”约定成口号的问题。而且在谍战剧中一对一接头可能还可以，在互联网应用中，客户太多，这样是不行的。</p>

<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>所以，只要是对称加密，就会永远在这个死循环里出不来，这个时候，就需要非对称加密介入进来。</p><br><p>非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个秘钥的私密性。但是，对应私钥的公钥，是可以在互联网上随意传播的，只要外卖网站把这个公钥给你，你们就可以愉快地互通了。</p><br><p>比如说你用公钥加密，说“我要定外卖”，黑客在中间就算截获了这个报文，因为它没有私钥也是解不开的，所以这个报文可以顺利到达外卖网站，外卖网站用私钥把这个报文解出来，然后回复，“那给我银行卡和支付密码吧”。</p><br><p>先别太乐观，这里还是有问题的。回复的这句话，是外卖网站拿私钥加密的，互联网上人人都可以把它打开，当然包括黑客。那外卖网站可以拿公钥加密吗？当然不能，因为它自己的私钥只有它自己知道，谁也解不开。</p><br><p>另外，这个过程还有一个问题，黑客也可以模拟发送“我要定外卖”这个过程的，因为它也有外卖网站的公钥。</p><br><p>为了解决这个问题，看来一对公钥私钥是不够的，客户端也需要有自己的公钥和私钥，并且客户端要把自己的公钥，给外卖网站。</p><br><p>这样，客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候，使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。</p>

<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。</p>

<p>这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。</p><br><p>例如，我自己搭建了一个网站 cliu8site，可以通过这个命令先创建私钥。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out cliu8siteprivate.key 1024</span><br></pre></td></tr></table></figure>
<p>然后，再根据这个私钥，创建对应的公钥。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in cliu8siteprivate.key -pubout -outcliu8sitepublic.pem</span><br></pre></td></tr></table></figure>
<p>这个时候就需要权威部门的介入了，就像每个人都可以打印自己的简历，说自己是谁，但是有公安局盖章的，就只有户口本，这个才能证明你是你。这个由权威部门颁发的称为<font size="3" color="red">证书</font>（<font size="3" color="red">Certificate</font>）。</p>

<p>证书里面有什么呢？当然应该有<strong><font size="3" color="red">公钥</font></strong>，这是最重要的；还有证书的<strong><font size="3" color="red">所有者</font></strong>，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；另外还有证书的<strong><font size="3" color="red">发布机构</font></strong>和证书的<strong><font size="3" color="red">有效期</font></strong>，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。</p>

<p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为<strong><font size="3" color="red">CA</font></strong>（ <strong><font size="3" color="red">Certificate Authority</font></strong>）。</p>

<p>证书请求可以通过这个命令生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req</span><br></pre></td></tr></table></figure>
<p>将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为 <strong> 签名算法。</strong> 问题又来了，那怎么签名才能保证是真的权威机构签名的呢？当然只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。</p><br><p>签名算法大概是这样工作的：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。</p><br><p>权威机构给证书签名的命令是这样的。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem</span><br></pre></td></tr></table></figure>
<p>这个命令会返回 Signature ok，而 cliu8sitecertificate.pem 就是签过名的证书。CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。</p>

<p>我们来查看这个证书的内容。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in cliu8sitecertificate.pem -noout -text</span><br></pre></td></tr></table></figure>
<p>这里面有个 Issuer，也即证书是谁颁发的；Subject，就是证书颁发给谁；Validity 是证书期限；Public-key 是公钥内容；Signature Algorithm 是签名算法。</p><br><p>这下好了，你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。</p><br><p>你有没有发现，又有新问题了。要想验证证书，需要 CA 的公钥，问题是，你怎么确定 CA 的公钥就是对的呢？</p><br><p>所以，CA 的公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠，要看 CA 的上级证书的公钥，能不能解开这个 CA 的签名。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性。这样层层上去，直到全球皆知的几个著名大 CA，称为<strong>root CA</strong>，做最后的背书。通过这种<strong>层层授信背书</strong>的方式，从而保证了非对称加密模式的正常运转。</p><br><p>除此之外，还有一种证书，称为<strong>Self-Signed Certificate</strong>，就是自己给自己签名。这个给人一种“我就是我，你爱信不信”的感觉。这里我就不多说了。</p>

<h3 id="HTTPS-的工作模式"><a href="#HTTPS-的工作模式" class="headerlink" title="HTTPS 的工作模式"></a>HTTPS 的工作模式</h3><p>我们可以知道，非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。</p>

<p>当然是可以的。这就是 HTTPS 协议的总体思路。</p>

<p><img src="https://static001.geekbang.org/resource/image/70/02/7042f5c3d9e3437d5b0b30b30f43c802.jpg" alt="image"></p>
<p>当你登录一个外卖网站的时候，由于是 HTTPS，客户端会发送 Client Hello 消息到服务器，以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有一个随机数，在协商对称密钥的时候使用。</p><br><p>这就类似在说：“您好，我想定外卖，但你要保密我吃的是什么。这是我的加密套路，再给你个随机数，你留着。”</p><br><p>然后，外卖网站返回 Server Hello 消息, 告诉客户端，服务器选择使用的协议版本、加密套件、压缩算法等，还有一个随机数，用于后续的密钥协商。</p><br><p>这就类似在说：“您好，保密没问题，你的加密套路还挺多，咱们就按套路 2 来吧，我这里也有个随机数，你也留着。”</p><br><p>然后，外卖网站会给你一个服务器端的证书，然后说：“Server Hello Done，我这里就这些信息了。”</p><br><p>你当然不相信这个证书，于是你从自己信任的 CA 仓库中，拿 CA 的证书里面的公钥去解密外卖网站的证书。如果能够成功，则说明外卖网站是可信的。这个过程中，你可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，反正直到一个授信的 CA，就可以了。</p><br><p>证书验证完毕之后，觉得这个外卖网站可信，于是客户端计算产生随机数字 Pre-master，发送 Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密出来。</p><br><p>到目前为止，无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。</p><br><p>有了对称密钥，客户端就可以说：“Change Cipher Spec，咱们以后都采用协商的通信密钥和加密算法进行加密通信了。”</p><br><p>然后发送一个 Encrypted Handshake Message，将已经商定好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。</p><br><p>同样，服务器也可以发送 Change Cipher Spec，说：“没问题，咱们以后都采用协商的通信密钥和加密算法进行加密通信了”，并且也发送 Encrypted Handshake Message 的消息试试。当双方握手结束之后，就可以通过对称密钥进行加密传输了。</p><br><p>这个过程除了加密解密之外，其他的过程和 HTTP 是一样的，过程也非常复杂。</p><br><p>上面的过程只包含了 HTTPS 的单向认证，也即客户端验证服务端的证书，是大部分的场景，也可以在更加严格安全要求的情况下，启用双向认证，双方互相验证证书。</p>

<h3 id="重放与篡改"><a href="#重放与篡改" class="headerlink" title="重放与篡改"></a>重放与篡改</h3><p>其实，这里还有一些没有解决的问题，例如重放和篡改的问题。</p><br><p>没错，有了加密和解密，黑客截获了包也打不开了，但是它可以发送 N 次。这个往往通过 Timestamp 和 Nonce 随机数联合起来，然后做一个不可逆的签名来保证。</p><br><p>Nonce 随机数保证唯一，或者 Timestamp 和 Nonce 合起来保证唯一，同样的，请求只接受一次，于是服务器多次受到相同的 Timestamp 和 Nonce，则视为无效即可。</p><br><p>如果有人想篡改 Timestamp 和 Nonce，还有签名保证不可篡改性，如果改了用签名算法解出来，就对不上了，可以丢弃了。</p>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><br><li><br><p><span class="orange">加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。</span></p><br></li><br><li><br><p><span class="orange"> 非对称加密需要通过证书和权威机构来验证公钥的合法性。</span></p><br></li><br><li><br><p><span class="orange">HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。</span></p><br></li><br></ul>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/十四、HTTP协议：看个新闻原来这么麻烦/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/十四、HTTP协议：看个新闻原来这么麻烦/" class="post-title-link" itemprop="url">十四、HTTP协议：看个新闻原来这么麻烦</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 11:13:27" itemprop="dateCreated datePublished" datetime="2019-03-28T11:13:27+08:00">2019-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面讲述完<strong>传输层</strong>，接下来开始讲<strong>应用层</strong>的协议。从哪里开始讲呢，就从咱们最常用的 HTTP 协议开始。</p>

<p>HTTP 协议，几乎是每个人上网用的第一个协议，同时也是很容易被人忽略的协议。</p><br><p>既然说看新闻，咱们就先登录 <a href="http://www.163.com/" target="_blank" rel="noopener">http://www.163.com</a> 。</p><br><p><a href="http://www.163.com/" target="_blank" rel="noopener">http://www.163.com</a> 是个 URL，叫作<strong>统一资源定位符</strong>。之所以叫统一，是因为它是有格式的。HTTP 称为协议，<a href="http://www.163.com" target="_blank" rel="noopener">www.163.com</a> 是一个域名，表示互联网上的一个位置。有的 URL 会有更详细的位置标识，例如 <a href="http://www.163.com/index.html" target="_blank" rel="noopener">http://www.163.com/index.html</a> 。正是因为这个东西是统一的，所以当你把这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。</p>

<h3 id="HTTP-请求的准备"><a href="#HTTP-请求的准备" class="headerlink" title="HTTP 请求的准备"></a>HTTP 请求的准备</h3><p>浏览器会将 <a href="http://www.163.com" target="_blank" rel="noopener">www.163.com</a> 这个域名发送给 <font size="3" color="red">DNS 服务器</font>，让它<font size="3" color="red">解析为 IP</font> 地址。有关 <font size="3" color="red">DNS</font> 的过程，其实非常复杂，这个在后面专门介绍 DNS 的时候，我会详细描述，这里我们先不管，反正它会被解析成为 IP 地址。那接下来是发送 <font size="3" color="red">HTTP</font> 请求吗？</p><br><p>不是的，<font size="3" color="red">HTTP</font> 是<font size="3" color="red">基于 TCP</font> 协议的，当然是要先建立 <font size="3" color="red">TCP</font> 连接了，怎么建立呢？还记得第 11 节讲过的三次握手吗？</p><br><p>目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 <font size="3" color="red">Keep-Alive</font> 的，这样建立的 <font size="3" color="red">TCP</font> 连接，就可以在多次请求中复用。</p><!-- [[[read_end]]] --><br><p>学习了 TCP 之后，你应该知道，TCP 的三次握手和四次挥手，还是挺费劲的。如果好不容易建立了连接，然后就做了一点儿事情就结束了，有点儿浪费人力和物力。</p>

<h3 id="HTTP-请求的构建"><a href="#HTTP-请求的构建" class="headerlink" title="HTTP 请求的构建"></a>HTTP 请求的构建</h3><p>建立了连接以后，浏览器就要发送 <font size="3" color="red">HTTP</font> 的请求。</p><br><p>请求的格式就像这样。</p>

<p><img src="https://static001.geekbang.org/resource/image/10/74/10ff27d1032bf32393195f23ef2f9874.jpg" alt="image"></p>
<p>HTTP 的报文大概分为三大部分。第一部分是<strong>请求行</strong>，第二部分是请求的<strong>首部</strong>，第三部分才是请求的<strong>正文实体</strong>。</p>

<h4 id="第一部分：请求行"><a href="#第一部分：请求行" class="headerlink" title="第一部分：请求行"></a>第一部分：请求行</h4><p>在请求行中，URL 就是 <a href="http://www.163.com/" target="_blank" rel="noopener">http://www.163.com</a> ，版本为 HTTP 1.1。这里要说一下的，就是方法。方法有几种类型。</p><br><p>对于访问网页来讲，最常用的类型就是<strong><font size="3" color="red">GET</font></strong>。顾名思义，GET 就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个 <font size="3" color="red">JSON</font> 字符串，到底要返回什么，是由服务器端的实现决定的。</p><br><p>例如，在云计算中，如果我们的服务器端要提供一个基于 <font size="3" color="red">HTTP</font> 协议的 <font size="3" color="red">API</font>，获取所有云主机的列表，这就会使用 <font size="3" color="red">GET</font> 方法得到，返回的可能是一个 <font size="3" color="red">JSON</font> 字符串。字符串里面是一个列表，列表里面是一项的云主机的信息。</p><br><p>另外一种类型叫做<strong><font size="3" color="red">POST</font></strong>。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是 <font size="3" color="red">JSON</font>。</p><br><p>例如，我们下一节要讲的支付场景，客户端就需要把“我是谁？我要支付多少？我要买啥？”告诉服务器，这就需要通过 <font size="3" color="red">POST</font> 方法。</p><br><p>再如，在云计算里，如果我们的服务器端，要提供一个基于 HTTP 协议的创建云主机的 API，也会用到 POST 方法。这个时候往往需要将“我要创建多大的云主机？多少 CPU 多少内存？多大硬盘？”这些信息放在 JSON 字符串里面，通过<font size="3" color="red"> POST</font> 的方法告诉服务器端。</p><br><p>还有一种类型叫<strong><font size="3" color="red">PUT</font></strong>，就是向指定资源位置上传最新内容。但是，<font size="3" color="red">HTTP 的服务器往往是不允许上传文件</font>的，所以 <font size="3" color="red">PUT 和 POST</font> 就都变成了要传给服务器东西的方法。</p><br><p>在实际使用过程中，这两者还会有稍许的区别。<font size="3" color="red">POST</font> 往往是用来创建一个资源的，而 <font size="3" color="red">PUT</font> 往往是用来修改一个资源的。</p><br><p>例如，云主机已经创建好了，我想对这个云主机打一个标签，说明这个云主机是生产环境的，另外一个云主机是测试环境的。那怎么修改这个标签呢？往往就是用<font size="3" color="red"> PUT</font> 方法。</p><br><p>再有一种常见的就是<strong><font size="3" color="red">DELETE</font></strong>。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用 <font size="3" color="red">DELETE 方法</font>。</p>

<h4 id="第二部分：首部字段"><a href="#第二部分：首部字段" class="headerlink" title="第二部分：首部字段"></a>第二部分：首部字段</h4><p>请求行下面就是我们的首部字段。首部是 <font size="3" color="red">key value</font>，通过<font size="3" color="red">冒号分隔</font>。这里面，往往保存了一些非常重要的字段。</p><br><p>例如，<strong><font size="3" color="red">Accept-Charset</font></strong>，表示<strong>客户端可以接受的字符集</strong>。防止传过来的是另外的字符集，从而导致出现乱码。</p><br><p>再如，<strong><font size="3" color="red">Content-Type</font></strong>是指<strong>正文的格式</strong>。例如，我们进行 POST 的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。</p><br><p>这里需要重点说一下的就是<strong><font size="3" color="red">缓存</font></strong>。为啥要使用缓存呢？那是因为一个非常大的页面有很多东西。</p><br><p>例如，我浏览一个商品的详情，里面有这个商品的价格、库存、展示图片、使用手册等等。商品的展示图片会保持较长时间不变，而库存会根据用户购买的情况经常改变。如果图片非常大，而库存数非常小，如果我们每次要更新数据的时候都要刷新整个页面，对于服务器的压力就会很大。</p><br><p>对于这种高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。</p><br><p>这个架构的图就像这样。</p>

<p><img src="https://static001.geekbang.org/resource/image/c8/ac/c81af7a52305f7de27e32e34a02d0eac.jpg" alt="image"></p>
<p>其中 <font size="3" color="red">DNS、CDN</font> 我在后面的章节会讲。和这一节关系比较大的就是 <font size="3" color="red">Nginx</font> 这一层，它如何处理 <font size="3" color="red">HTTP 协议</font>呢？对于静态资源，有 <font size="3" color="red">Vanish</font> 缓存层。当缓存过期的时候，才会访问真正的 <font size="3" color="red">Tomcat 应用集群</font>。</p><br><p>在 <font size="3" color="red">HTTP</font> 头里面，<strong><font size="3" color="red">Cache-control</font></strong>是用来<strong>控制缓存</strong>的。当客户端发送的请求中包含 <font size="3" color="red">max-age</font> 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。</p><br><p>另外，<strong><font size="3" color="red">If-Modified-Since</font></strong>也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回<font size="3" color="red">“304 Not Modified”</font>的响应，那客户端就不用下载了，也会节省带宽。</p><br><p>到此为止，我们仅仅是拼凑起了 <font size="3" color="red">HTTP</font> 请求的报文格式，接下来，浏览器会把它交给下一层传输层。怎么交给传输层呢？其实也无非是用 <font size="3" color="red">Socket</font> 这些东西，只不过用的浏览器里，这些程序不需要你自己写，有人已经帮你写好了。</p>

<h3 id="HTTP-请求的发送"><a href="#HTTP-请求的发送" class="headerlink" title="HTTP 请求的发送"></a>HTTP 请求的发送</h3><p><font size="3" color="red">HTTP</font> 协议是<font size="3" color="red">基于 TCP</font> 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。当然，到了 <font size="3" color="red">TCP</font> 层，它会把二进制流变成一个的报文段发送给服务器。</p><br><p>在发送给每个报文段的时候，都需要对方有一个回应 <font size="3" color="red">ACK</font>，来保证报文可靠地到达了对方。如果没有回应，那么 <font size="3" color="red">TCP</font> 这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是 HTTP 这一层不需要知道这一点，因为是 <font size="3" color="red">TCP</font> 这一层在埋头苦干。</p><br><p><font size="3" color="red">TCP</font> 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到 IP 头里面，交给 <font size="3" color="red">IP 层</font>进行传输。</p><br><p><font size="3" color="red">IP </font>层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 <font size="3" color="red">ARP</font> 协议来请求这个目标地址对应的 <font size="3" color="red">MAC </font>地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到<font size="3" color="red">网关</font>，还要需要发送<font size="3" color="red"> ARP</font> 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。</p><br><p>网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。</p><br><p>这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送<font size="3" color="red"> ARP</font>，获得这个目标地址的 MAC 地址，将包发出去。</p><br><p>目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 <font size="3" color="red">TCP </font>协议，于是解析 <font size="3" color="red">TCP</font> 的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个 <font size="3" color="red">ACK</font>，如果不是就丢弃。</p><br><p>TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。</p>

<h3 id="HTTP-返回的构建"><a href="#HTTP-返回的构建" class="headerlink" title="HTTP 返回的构建"></a>HTTP 返回的构建</h3><p>HTTP 的返回报文也是有一定格式的。这也是基于 HTTP 1.1 的。</p>

<p><img src="https://static001.geekbang.org/resource/image/1c/c1/1c2cfd4326d0dfca652ac8501321fac1.jpg" alt="image"></p>
<p>状态码会反应 HTTP 请求的结果。<font size="3" color="red">“200”意味着大吉大利</font>；而我们最不想见的，就是<font size="3" color="red">“404”</font>，也就是<font size="3" color="red">“服务端无法响应这个请求”</font>。然后，短语会大概说一下原因。</p><br><p>接下来是返回首部的<strong>key value</strong>。</p><br><p>这里面，<strong><font size="3" color="red">Retry-After</font></strong>表示，告诉客户端应该在多长时间以后再次尝试一下。<font size="3" color="red">“503 错误”</font>是说<font size="3" color="red">“服务暂时不再和这个值配合使用”</font>。</p><br><p>在返回的头部里面也会有<strong><font size="3" color="red">Content-Type</font></strong>，表示返回的是 HTML，还是 JSON。</p><br><p>构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去。还是交给 Socket 去发送，还是交给 TCP 层，让 TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达。</p><br><p>这些段加上 <font size="3" color="red">TCP </font>头后会交给 IP 层，然后把刚才的发送过程反向走一遍。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。</p><br><p>客户端发现 MAC 地址符合、IP 地址符合，于是就会交给 TCP 层。根据序列号看是不是自己要的报文段，如果是，则会根据 TCP 头中的端口号，发给相应的进程。这个进程就是浏览器，浏览器作为客户端也在监听某个端口。</p><br><p>当浏览器拿到了 HTTP 的报文。发现返回<font size="3" color="red">“200”，一切正常</font>，于是就从正文中将 HTML 拿出来。HTML 是一个标准的网页格式。浏览器只要根据这个格式，展示出一个绚丽多彩的网页。</p><br><p>这就是一个正常的 HTTP 请求和返回的完整过程。</p>

<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>当然 HTTP 协议也在不断地进化过程中，在 <font size="3" color="red">HTTP1.1</font> 基础上便有了 HTTP 2.0。</p><br><p>HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 <font size="3" color="red">pipeline</font> 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。</p><br><p>为了解决这些问题，<font size="3" color="red">HTTP 2.0</font> 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 <font size="3" color="red">key  value</font> 在两端建立一个<font size="3" color="red">索引表</font>，对相同的头只发送索引表中的索引。</p><br><p>另外，<font size="3" color="red">HTTP 2.0</font> 协议将一个 <font size="3" color="red">TCP</font> 的连接中，<font size="3" color="red">切分成多个流</font>，每个流都有自己的<font size="3" color="red"> ID</font>，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。</p><br><p><font size="3" color="red">HTTP 2.0</font> 还将所有的传输信息分割为更小的<font size="3" color="red">消息和帧</font>，并对它们采用二进制格式编码。常见的帧有<strong><font size="3" color="red">Header 帧</font></strong>，用于传输 Header 内容，并且会开启一个新的流。再就是<strong>Data 帧</strong>，用来传输正文实体。多个 <font size="3" color="red">Data 帧</font>属于同一个流。</p><br><p>通过这两种机制，<font size="3" color="red">HTTP 2.0</font> 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p><br><p>我们来举一个例子。</p><br><p>假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 <font size="3" color="red">HTTP 1.1 就是串行</font>的，但是如果使用 <font size="3" color="red">HTTP 2.0</font>，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p>

<p><img src="https://static001.geekbang.org/resource/image/0b/7a/0bc51f8f887aae04ef89a1a88cb5a17a.jpg" alt="image"></p>
<p>HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。</p>

<p><img src="https://static001.geekbang.org/resource/image/03/dd/03d4a216c024a9e761ed43c6787bf7dd.jpg" alt="image"></p>
<p><font size="3" color="red">HTTP 2.0 成功解决了HTTP 1.1 的队首阻塞问题</font>，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；<font size="3" color="red">减少了 TCP 连接数对服务器性能的影响</font>，同时将页面的多个数据 css、js、 jpg 等通过一个<font size="3" color="red">数据链</font>接进行传输，能够<font size="3" color="red">加快页面组件的传输速度</font>。</p>

<h3 id="QUIC-协议的“城会玩”"><a href="#QUIC-协议的“城会玩”" class="headerlink" title="QUIC 协议的“城会玩”"></a>QUIC 协议的“城会玩”</h3><p><font size="3" color="red">HTTP 2.0</font> 虽然大大增加了并发性，但还是有问题的。因为 <font size="3" color="red">HTTP 2.0</font> 也是<font size="3" color="red">基于 TCP</font> 协议的，<font size="3" color="red">TCP</font> 协议在处理包时是有严格顺序的。</p><br><p>当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。</p><br><p>于是，就又到了从 TCP 切换到 UDP，进行“城会玩”的时候了。这就是 <font size="3" color="red">Google 的 QUIC 协议</font>，接下来我们来看它是如何“城会玩”的。</p>

<h4 id="机制一：自定义连接机制"><a href="#机制一：自定义连接机制" class="headerlink" title="机制一：自定义连接机制"></a>机制一：自定义连接机制</h4><p>我们都知道，一条 <font size="3" color="red">TCP</font> 连接是由<font size="3" color="red">四元组</font>标识的，分别是<font size="3" color="red">源 IP</font>、<font size="3" color="red">源端口</font>、<font size="3" color="red">目的 IP</font>、<font size="3" color="red">目的端口</font>。一旦一个元素发生变化时，就需要断开重连，重新连接。在移动互联情况下，当手机信号不稳定或者在 WIFI 和 移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延。</p><br><p>这在 <font size="3" color="red">TCP</font> 是没有办法的，但是基于<font size="3" color="red"> UDP</font>，就可以在<font size="3" color="red"> QUIC</font> 自己的逻辑里面维护连接的机制，<font size="3" color="red">不再以四元组标识</font>，而是以一个 <font size="3" color="red">64 位的随机数</font>作为 <font size="3" color="red">ID</font> 来标识，而且 <font size="3" color="red">UDP</font> 是无连接的，所以<font size="3" color="red">当 IP 或者端口变化</font>的时候，只要 <font size="3" color="red">ID</font> 不变，就不需要重新建立连接。</p>

<h4 id="机制二：自定义重传机制"><a href="#机制二：自定义重传机制" class="headerlink" title="机制二：自定义重传机制"></a>机制二：自定义重传机制</h4><p>前面我们讲过，<font size="3" color="red">TCP</font> 为了保证可靠性，通过使用<strong><font size="3" color="red">序号</font></strong>和<strong><font size="3" color="red">应答</font></strong>机制，来解决顺序问题和丢包问题。</p><br><p>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包。那怎么样才算超时呢？还记得我们提过的<strong><font size="3" color="red">自适应重传算法</font></strong>吗？这个超时是通过<strong><font size="3" color="red">采样往返时间 RTT</font></strong>不断调整的。</p><br><p>其实，在 <font size="3" color="red">TCP</font> 里面超时的采样存在不准确的问题。例如，发送一个包，序号为 100，发现没有返回，于是再发送一个 100，过一阵返回一个 ACK101。这个时候客户端知道这个包肯定收到了，但是往返时间是多少呢？是 ACK 到达的时间减去后一个 100 发送的时间，还是减去前一个 100 发送的时间呢？事实是，第一种算法把时间算短了，第二种算法把时间算长了。</p><br><p><font size="3" color="red">QUIC</font> 也有个<font size="3" color="red">序列号</font>，是<font size="3" color="red">递增</font>的。<font size="3" color="red">任何一个序列号的包只发送一次，下次就要加一了</font>。例如，发送一个包，序号是 100，发现没有返回；再次发送的时候，序号就是 101 了；如果返回的 ACK  100，就是对第一个包的响应。如果返回 ACK  101 就是对第二个包的响应，<font size="3" color="red">RTT 计算相对准确</font>。</p><br><p>但是这里有一个<font size="3" color="red">问题</font>，<font size="3" color="red">就是怎么知道包 100 和包 101 发送的是同样的内容呢</font>？<font size="3" color="red">QUIC 定义了一个 offset</font> 概念。<font size="3" color="red">QUIC 既然是面向连接</font>的，也就<font size="3" color="red">像 TCP</font> 一样，是一个数据流，发送的数据在这个数据流里面有个偏移量<font size="3" color="red"> offset</font>，可以通过 <font size="3" color="red">offset</font> 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发；如果来了，按照 offset 拼接，还是能够拼成一个流。</p>

<p><img src="https://static001.geekbang.org/resource/image/da/c4/da2af1e419db66929dc85107c7250fc4.jpg" alt="image"></p>
<h4 id="机制三：无阻塞的多路复用"><a href="#机制三：无阻塞的多路复用" class="headerlink" title="机制三：无阻塞的多路复用"></a>机制三：无阻塞的多路复用</h4><p>有了自定义的连接和重传机制，我们就可以解决上面 <font size="3" color="red">HTTP  2.0</font> 的多路复用问题。</p><br><p>同 <font size="3" color="red">HTTP 2.0</font> 一样，同一条 <font size="3" color="red">QUIC</font> 连接上可以创建多个 <font size="3" color="red">stream</font>，来发送多个 <font size="3" color="red">HTTP</font> 请求。但是，<font size="3" color="red">QUIC</font> 是基于 <font size="3" color="red">UDP</font> 的，一个连接上的多个 <font size="3" color="red">stream</font> 之间没有依赖。这样，假如 <font size="3" color="red">stream2</font> 丢了一个 <font size="3" color="red">UDP</font> 包，后面跟着 <font size="3" color="red">stream3</font> 的一个 <font size="3" color="red">UDP</font> 包，<font size="3" color="red">虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户。</font></p>

<h4 id="机制四：自定义流量控制"><a href="#机制四：自定义流量控制" class="headerlink" title="机制四：自定义流量控制"></a>机制四：自定义流量控制</h4><p><font size="3" color="red">TCP</font> 的流量控制是通过<strong><font size="3" color="red">滑动窗口协议</font></strong>。<font size="3" color="red">QUIC</font> 的流量控制也是通过<font size="3" color="red"> window_update</font>，来告诉对端它可以接受的字节数。但是 <font size="3" color="red">QUIC</font> 的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口。</p><br><p>还记得吗？在 <font size="3" color="red">TCP</font> 协议中，接收端的窗口的起始点是下一个要接收并且 <font size="3" color="red">ACK</font> 的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为 <font size="3" color="red">TCP</font> 的 <font size="3" color="red">ACK</font> 机制是基于序列号的累计应答，一旦 <font size="3" color="red">ACK</font> 了一个系列号，就说明前面的都到了，所以只要前面的没到，后面的到了也不能 <font size="3" color="red">ACK</font>，就会导致后面的到了，也有可能超时重传，浪费带宽。</p><br><p><font size="3" color="red">QUIC</font> 的 <font size="3" color="red">ACK</font> 是基于 <font size="3" color="red">offset</font> 的，每个<font size="3" color="red"> offset</font> 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空挡会等待到来或者重发即可，而窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小。显然，这样更加准确。</p>

<p><img src="https://static001.geekbang.org/resource/image/a6/22/a66563b46906e7708cc69a02d43afb22.jpg" alt="image"></p>
<p>另外，还有整个连接的窗口，需要对于所有的 stream 的窗口做一个统计。</p>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><br><li><p><span class="orange">HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；</span></p><br></li><br><li><p><span class="orange">HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；</span></p><br></li><br><li><p><span class="orange">QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</span></p><br></li><br></ul>






          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/十二、TCP协议（下）：西行必定多妖孽，恒心智慧消磨难/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/十二、TCP协议（下）：西行必定多妖孽，恒心智慧消磨难/" class="post-title-link" itemprop="url">十二、TCP协议（下）：西行必定多妖孽，恒心智慧消磨难</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 11:12:53" itemprop="dateCreated datePublished" datetime="2019-03-28T11:12:53+08:00">2019-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们前面说到玄奘西行，要出网关。既然出了网关，那就是在公网上传输数据，公网往往是不可靠的，因而需要很多的机制去保证传输的可靠性，这里面需要恒心，也即各种<strong>重传的策略</strong>，还需要有智慧，也就是说，这里面包含着<strong>大量的算法</strong>。</p>

<h3 id="如何做个靠谱的人？"><a href="#如何做个靠谱的人？" class="headerlink" title="如何做个靠谱的人？"></a>如何做个靠谱的人？</h3><p><font size="3" color="red">TCP</font> 想成为一个成熟稳重的人，成为一个靠谱的人。那一个人怎么样才算靠谱呢？咱们工作中经常就有这样的场景，比如你交代给下属一个事情以后，下属到底能不能做到，做到什么程度，什么时候能够交付，往往就会有应答，有回复。这样，处理事情的过程中，一旦有异常，你也可以尽快知道，而不是交代完之后就石沉大海，过了一个月再问，他说，啊我不记得了。</p>

<p>对应到网络协议上，就是客户端每发送的一个包，服务器端都应该有个回复，如果服务器端超过一定的时间没有回复，客户端就会重新发送这个包，直到有回复。</p>

<p>这个发送应答的过程是什么样呢？可以是<strong>上一个收到了应答，再发送下一个</strong>。这种模式有点像两个人直接打电话，你一句，我一句。但是这种方式的缺点是效率比较低。如果一方在电话那头处理的时间比较长，这一头就要干等着，双方都没办法干其他事情。咱们在日常工作中也不是这样的，不能你交代你的下属办一件事情，就一直打着电话看着他做，而是应该他按照你的安排，先将事情记录下来，办完一件回复一件。在他办事情的过程中，你还可以同时交代新的事情，这样双方就并行了。</p>

<p>如果使⽤这种模式，其实需要你和你的下属就不能靠脑⼦了，⽽是要都准备⼀个本⼦，你每交代下属⼀个事情，双方的本子都要记录⼀下。</p>

<p>当你的下属做完⼀件事情，就回复你，做完了，你就在你的本⼦上将这个事情划去。同时你的本⼦上每件事情都有时限，如果超过了时限下属还没有回复，你就要主动重新交代⼀下：上次那件事情，你还没回复我，咋样啦？</p>

<p>既然多件事情可以一起处理，那就需要给每个事情编个号，防止弄错了。例如，程序员平时看任务的时候，都会看 JIRA 的 ID，而不是每次都要描述一下具体的事情。在大部分情况下，对于事情的处理是按照顺序来的，先来的先处理，这就给应答和汇报工作带来了方便。等开周会的时候，每个程序员都可以将 JIRA ID 的列表拉出来，说以上的都做完了，⽽不⽤⼀个个说。</p>

<h3 id="如何实现一个靠谱的协议？"><a href="#如何实现一个靠谱的协议？" class="headerlink" title="如何实现一个靠谱的协议？"></a>如何实现一个靠谱的协议？</h3><p><font size="3" color="red">TCP</font> 协议使用的也是同样的模式。为了保证顺序性，每一个包都有一个 <font size="3" color="red">ID</font>。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为<font size="3" color="red">累计确认</font>或者<font size="3" color="red">累计应答</font>（<strong>cumulative acknowledgment</strong>）。</p>

<p>为了记录所有发送的包和接收的包，<font size="3" color="red">TCP</font> 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 <font size="3" color="red">ID</font> 一个个排列，根据处理的情况分成四个部分。</p><br><p>第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的。</p><br><p>第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉。</p><br><p>第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的。</p><br><p>第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。</p><br><p>这里面为什么要区分第三部分和第四部分呢？没交代的，一下子全交代了不就完了吗？</p>

<p>这就是我们上一节提到的十个词口诀里的“流量控制，把握分寸”。作为项目管理人员，你应该根据以往的工作情况和这个员工反馈的能力、抗压力等，先在心中估测一下，这个人一天能做多少工作。如果工作布置少了，就会不饱和；如果工作布置多了，他就会做不完；如果你使劲逼迫，人家可能就要辞职了。</p>

<p>到底一个员工能够同时处理多少事情呢？在 <font size="3" color="red">TCP</font> 里，接收端会给发送端报一个窗口的大小，叫<strong>Advertised window</strong>。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。</p>

<p>于是，发送端需要保持下面的数据结构。</p>

<p><img src="https://static001.geekbang.org/resource/image/16/7b/16dcd6fb8105a1caa75887b5ffa0bd7b.jpg" alt="image"></p>
<ul><br><li><p>LastByteAcked：第一部分和第二部分的分界线</p><br></li><br><li><p>LastByteSent：第二部分和第三部分的分界线</p><br></li><br><li><p>LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线</p><br></li><br></ul>

<p>对于接收端来讲，它的缓存里记录的内容要简单一些。</p><br><p>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的。</p><br><p>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量。</p><br><p>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</p><br><p>对应的数据结构就像这样。<br><br><img src="https://static001.geekbang.org/resource/image/f7/a4/f7b1d3bc6b6d8e55f0951e82294c8ba4.jpg" alt="image"><br><br><ul><br><li><p>MaxRcvBuffer：最大缓存的量；</p><br></li><br><li><p>LastByteRead 之后是已经接收了，但是还没被应用层读取的；</p><br></li><br><li><p>NextByteExpected 是第一部分和第二部分的分界线。</p><br></li><br></ul><br><br></p><p>第二部分的窗口有多大呢？</p><br><p>NextByteExpected 和 LastByteRead 的差其实是还没被应用层读取的部分占用掉的 MaxRcvBuffer 的量，我们定义为 A。</p><br><p>AdvertisedWindow 其实是 MaxRcvBuffer 减去 A。</p><br><p>也就是：AdvertisedWindow=MaxRcvBuffer-((NextByteExpected-1)-LastByteRead)。</p><br><p>那第二部分和第三部分的分界线在哪里呢？NextByteExpected 加 AdvertisedWindow 就是第二部分和第三部分的分界线，其实也就是 LastByteRead 加上 MaxRcvBuffer。</p>

<p>其中第二部分里面，由于受到的包可能不是顺序的，会出现空挡，只有和第一部分连续的，可以马上进行回复，中间空着的部分需要等待，哪怕后面的已经来了。</p>

<h3 id="顺序问题与丢包问题"><a href="#顺序问题与丢包问题" class="headerlink" title="顺序问题与丢包问题"></a>顺序问题与丢包问题</h3><p>接下来我们结合一个例子来看。</p><br><p>还是刚才的图，在发送端来看，1、2、3 已经发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p><br><p>在接收端来看，1、2、3、4、5 是已经完成 ACK，但是没读取的；6、7 是等待接收的；8、9 是已经接收，但是没有 ACK 的。</p><br><p>发送端和接收端当前的状态如下：</p><br><ul><br><li><p>1、2、3 没有问题，双方达成了一致。</p><br></li><br><li><p>4、5 接收方说 ACK 了，但是发送方还没收到，有可能丢了，有可能在路上。</p><br></li><br><li><p>6、7、8、9 肯定都发了，但是 8、9 已经到了，但是 6、7 没到，出现了乱序，缓存着但是没办法 ACK。</p><br></li><br></ul><br><p>根据这个例子，我们可以知道，顺序问题和丢包问题都有可能发生，所以我们先来看<strong>确认与重发的机制</strong>。</p><br><p>假设 4 的确认到了，不幸的是，5 的 ACK 丢了，6、7 的数据包丢了，这该怎么办呢？</p><br><p>一种方法就是<strong>超时重试</strong>，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。但是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。</p><br><p>估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为<strong>自适应重传算法</strong>（<strong>Adaptive Retransmission Algorithm</strong>）。</p><br><p>如果过一段时间，5、6、7 都超时了，就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，有需要重传的时候，TCP 的策略是<strong>超时间隔加倍</strong>。<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍</strong>。<strong>两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p><br><p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p><br><p>有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。</p><br><p>例如，接收方发现 6、8、9 都已经接收了，就是 7 没来，那肯定是丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p><br><p>还有一种方式称为<strong>Selective Acknowledgment</strong>  （<strong>SACK</strong>）。这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。</p>

<h3 id="流量控制问题"><a href="#流量控制问题" class="headerlink" title="流量控制问题"></a>流量控制问题</h3><p>我们再来看流量控制机制，在对于包的确认中，同时会携带一个窗口的大小。</p><br><p>我们先假设窗口不变的情况，窗口始终为 9。4 的确认来的时候，会右移一个，这个时候第 13 个包也可以发送了。</p>

<p><img src="https://static001.geekbang.org/resource/image/73/33/7339fd8973865164d25227cac206ca33.jpg" alt="image"></p>
<p>这个时候，假设发送端发送过猛，会将第三部分的 10、11、12、13 全部发送完毕，之后就停止发送了，未发送可发送部分为 0。</p>

<p><img src="https://static001.geekbang.org/resource/image/06/d2/06cc25118730fbf611eb315705420ed2.jpg" alt="image"></p>
<p>当对于包 5 的确认到达的时候，在客户端相当于窗口再滑动了一格，这个时候，才可以有更多的包可以发送了，例如第 14 个包才可以发送。</p>

<p><img src="https://static001.geekbang.org/resource/image/bd/c3/bddb59ebbf7eecc4853cafce0bb1dcc3.jpg" alt="image"></p>
<p>如果接收方实在处理的太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小，甚至可以设置为 0，则发送方将暂时停止发送。</p>

<p>我们假设一个极端情况，接收端的应用一直不读取缓存中的数据，当数据包 6 确认后，窗口大小就不能再是 9 了，就要缩小一个变为 8。</p>

<p><img src="https://static001.geekbang.org/resource/image/92/31/92f66b1556b76c46c669aba232d35a31.jpg" alt="image"></p>
<p>这个新的窗口 8 通过 6 的确认消息到达发送端的时候，你会发现窗口没有平行右移，而是仅仅左面的边右移了，窗口的大小从 9 改成了 8。</p>

<p><img src="https://static001.geekbang.org/resource/image/a7/ba/a78f5195ebf9b4f9dc4ea5a9b91e94ba.jpg" alt="image"></p>
<p>如果接收端还是一直不处理数据，则随着确认的包越来越多，窗口越来越小，直到为 0。</p>

<p><img src="https://static001.geekbang.org/resource/image/15/d2/150f28d9e745952f5968eff05e3f0ad2.jpg" alt="image"></p>
<p>当这个窗口通过包 14 的确认到达发送端的时候，发送端的窗口也调整为 0，停止发送。</p>

<p><img src="https://static001.geekbang.org/resource/image/30/30/3014a6a259f74b0c950bf3067581ac30.jpg" alt="image"></p>
<p>如果这样的话，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。</p><br><p>这就是我们常说的流量控制。</p>

<h3 id="拥塞控制问题"><a href="#拥塞控制问题" class="headerlink" title="拥塞控制问题"></a>拥塞控制问题</h3><p>最后，我们看一下拥塞控制的问题，也是通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。</p><br><p>这里有一个公式 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。</p><br><p>那发送方怎么判断网络是不是满呢？这其实是个挺难的事情，因为对于 TCP 协议来讲，他压根不知道整个网络路径都会经历什么，对他来讲就是一个黑盒。TCP 发送包常被比喻为往一个水管里面灌水，而 TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。</p><br><p>水管有粗细，网络有带宽，也即每秒钟能够发送多少数据；水管有长度，端到端有时延。在理想状态下，水管里面水的量 = 水管粗细 x 水管长度。对于到网络上，通道的容量 = 带宽 × 往返延迟。</p><br><p>如果我们设置发送窗口，使得发送但未确认的包为为通道的容量，就能够撑满整个管道。</p>

<p><img src="https://static001.geekbang.org/resource/image/db/e6/db8510541662281175803c7f9d1fcae6.jpg" alt="image"></p>
<p>如图所示，假设往返时间为 8s，去 4s，回 4s，每秒发送一个包，每个包 1024byte。已经过去了 8s，则 8 个包都发出去了，其中前 4 个包已经到达接收端，但是 ACK 还没有返回，不能算发送成功。5-8 后四个包还在路上，还没被接收。这个时候，整个管道正好撑满，在发送端，已发送未确认的为 8 个包，正好等于带宽，也即每秒发送 1 个包，乘以来回时间 8s。</p><br><p>如果我们在这个基础上再调大窗口，使得单位时间内更多的包可以发送，会出现什么现象呢？</p><br><p>我们来想，原来发送一个包，从一端到达另一端，假设一共经过四个设备，每个设备处理一个包时间耗费 1s，所以到达另一端需要耗费 4s，如果发送的更加快速，则单位时间内，会有更多的包到达这些中间设备，这些设备还是只能每秒处理一个包的话，多出来的包就会被丢弃，这是我们不想看到的。</p><br><p>这个时候，我们可以想其他的办法，例如这个四个设备本来每秒处理一个包，但是我们在这些设备上加缓存，处理不过来的在队列里面排着，这样包就不会丢失，但是缺点是会增加时延，这个缓存的包，4s 肯定到达不了接收端了，如果时延达到一定程度，就会超时重传，也是我们不想看到的。</p><br><p>于是 TCP 的拥塞控制主要来避免两种现象，<strong>包丢失</strong>和<strong>超时重传</strong>。一旦出现了这些现象就说明，发送速度太快了，要慢一点。但是一开始我怎么知道速度多快呢，我怎么知道应该把窗口调整到多大呢？</p><br><p>如果我们通过漏斗往瓶子里灌水，我们就知道，不能一桶水一下子倒进去，肯定会溅出来，要一开始慢慢的倒，然后发现总能够倒进去，就可以越倒越快。这叫作慢启动。</p><br><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是<strong>指数性的增长</strong>。</p><br><p>涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。</p><br><p>每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了线性增长。</p><br><p>但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。</p><br><p>拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。</p><br><p>前面我们讲过<strong>快速重传算法</strong>。当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。</p>

<p><img src="https://static001.geekbang.org/resource/image/19/d2/1910bc1a0048d4de7b2128eb0f5dbcd2.jpg" alt="image"></p>
<p>就像前面说的一样，正是这种知进退，使得时延很重要的情况下，反而降低了速度。但是如果你仔细想一下，TCP 的拥塞控制主要来避免的两个现象都是有问题的。</p><br><p><strong>第一个问题</strong>是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。</p><br><p><strong>第二个问题</strong>是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。</p><br><p>为了优化这两个问题，后来有了<strong>TCP BBR 拥塞算法</strong>。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。</p>

<p><img src="https://static001.geekbang.org/resource/image/a2/4c/a2b3a5df5eca52e302b75824e4bbbd4c.jpg" alt="image"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><br><li><p>顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少；</p><br></li><br><li><p>拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。</p><br></li><br></ul>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/十一、TCP协议（上）：因性恶而复杂，先恶后善反轻松/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/十一、TCP协议（上）：因性恶而复杂，先恶后善反轻松/" class="post-title-link" itemprop="url">十一、TCP协议（上）：因性恶而复杂，先恶后善反轻松</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 11:12:26" itemprop="dateCreated datePublished" datetime="2019-03-28T11:12:26+08:00">2019-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一节，我们讲的 UDP，基本上包括了传输层所必须的端口字段。它就像我们小时候一样简单，相信“网之初，性本善，不丢包，不乱序”。</p><br><p>后来呢，我们都慢慢长大，了解了社会的残酷，变得复杂而成熟，就像 TCP 协议一样。它之所以这么复杂，那是因为它秉承的是“性恶论”。它天然认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。</p>

<h3 id="TCP-包头格式"><a href="#TCP-包头格式" class="headerlink" title="TCP 包头格式"></a>TCP 包头格式</h3><p>我们先来看 <font size="3" color="red">TCP</font> 头的格式。从这个图上可以看出，它比 <font size="3" color="red">UDP</font> 复杂得多。</p>

<p><img src="https://static001.geekbang.org/resource/image/a7/bf/a795461effcce686a43f48e094c9adbf.jpg" alt="image"></p>
<p>首先，<font size="3" color="red">源端口号</font>和<font size="3" color="red">目标端口号</font>是不可少的，这一点和 <font size="3" color="red">UDP</font> 是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。</p><br><p>接下来是<font size="3" color="red">包的序号</font>。为什么要给包编号呢？当然是为了<font size="3" color="red">解决乱序</font>的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。既然是社会老司机，做事当然要稳重，一件件来，面临再复杂的情况，也临危不乱。</p><br><p>还应该有的就是<font size="3" color="red">确认序号</font>。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以<font size="3" color="red">解决不丢包</font>的问题。作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。</p><br><p><font size="3" color="red">TCP</font> 是靠谱的协议，但是这不能说明它面临的网络环境好。从 <font size="3" color="red">IP</font> 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 <font size="3" color="red">IP</font> 的上一层 <font size="3" color="red">TCP</font> 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 <font size="3" color="red">TCP</font> 来讲，<font size="3" color="red">IP</font> 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。</p><br><p>这有点像如果你在北京，和客户约十点见面，那么你应该清楚堵车是常态，你干预不了，也控制不了，你唯一能做的就是早走。打车不行就改乘地铁，尽力不失约。</p><br><p>接下来有一些状态位。例如 <font size="3" color="red">SYN</font> 是发起一个连接，<font size="3" color="red">ACK</font> 是回复，<font size="3" color="red">RST</font> 是重新连接，<font size="3" color="red">FIN</font> 是结束连接等。<font size="3" color="red">TCP</font> 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p>

<p>不像小时候，随便一个不认识的小朋友都能玩在一起，人大了，就变得礼貌，优雅而警觉，人与人遇到会互相热情的寒暄，离开会不舍的道别，但是人与人之间的信任会经过多次交互才能建立。</p>

<p>还有一个重要的就是窗口大小。<font size="3" color="red">TCP</font> 要做<font size="3" color="red">流量控制</font>，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p>

<p>作为老司机，做事情要有分寸，待人要把握尺度，既能适当提出自己的要求，又不强人所难。除了做流量控制以外，<font size="3" color="red">TCP</font> 还会做<font size="3" color="red">拥塞控制</font>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即<font size="3" color="red">控制发送的速度</font>。不能改变世界，就改变自己嘛。</p><br><p>作为老司机，要会自我控制，知进退，知道什么时候应该坚持，什么时候应该让步。</p><br><p>通过对 <font size="3" color="red">TCP</font> 头的解析，我们知道要掌握<font size="3" color="red"> TCP</font> 协议，重点应该关注以下几个问题：</p>

<ul><br><li><p>顺序问题 ，稳重不乱；</p><br></li><br><li><p>丢包问题，承诺靠谱；</p><br></li><br><li><p>连接维护，有始有终；</p><br></li><br><li><p>流量控制，把握分寸；</p><br></li><br><li><p>拥塞控制，知进知退。</p><br></li><br></ul>

<h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>所有的问题，首先都要先建立一个连接，所以我们先来看连接维护问题。</p><br><p><font size="3" color="red">TCP</font> 的<font size="3" color="red">连接建立</font>，我们常常称为三次握手。</p><br><p>A：您好，我是 A。</p><br><p>B：您好 A，我是 B。</p><br><p>A：您好 B。</p>

<p>我们也常称为<font size="3" color="red">“请求 -&gt; 应答 -&gt; 应答之应答”</font>的三个回合。这个看起来简单，其实里面还是有很多的学问，很多的细节。</p><br><p>首先，为什么要三次，而不是两次？按说两个人打招呼，一来一回就可以了啊？为了可靠，为什么不是四次？</p><br><p>我们还是假设这个<font size="3" color="red">通路</font>是非常<font size="3" color="red">不可靠</font>的，<font size="3" color="red">A</font> 要发起一个连接，当发了第一个请求杳无音信的时候，会有很多的可能性，比如第一个请求包丢了，再如没有丢，但是绕了弯路，超时了，还有 <font size="3" color="red">B</font> 没有响应，不想和我连接。</p>

<p><font size="3" color="red">A</font> 不能确认结果，于是再发，再发。终于，有一个请求包到了 <font size="3" color="red">B</font>，但是请求包到了<font size="3" color="red"> B</font> 的这个事情，目前 <font size="3" color="red">A</font> 还<font size="3" color="red">是不知道的</font>，<font size="3" color="red">A 还有可能再发</font>。</p>

<p><font size="3" color="red">B</font> 收到了请求包，就知道了 <font size="3" color="red">A</font> 的存在，并且知道 <font size="3" color="red">A</font> 要<font size="3" color="red">和它建立连接</font>。如果 <font size="3" color="red">B</font> <font size="3" color="red">不乐意建立连接</font>，则 <font size="3" color="red">A</font> 会重试一阵后放弃，连接建立失败，没有问题；如果 <font size="3" color="red">B</font> 是<font size="3" color="red">乐意建立连接</font>的，则会<font size="3" color="red">发送应答包给 A</font>。</p>

<p>当然对于 <font size="3" color="red">B</font> 来说，这个应答包也是一入网络深似海，不知道能不能到达 <font size="3" color="red">A</font>。这个时候 <font size="3" color="red">B</font> 自然不能认为连接是建立好了，因为应答包仍然会丢，会绕弯路，或者 <font size="3" color="red">A</font> 已经挂了都有可能。</p>

<p>而且这个时候 <font size="3" color="red">B</font> 还能碰到一个诡异的现象就是，<font size="3" color="red">A</font> 和 <font size="3" color="red">B</font> 原来建立了连接，做了简单通信后，结束了连接。还记得吗？A 建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了，B 会认为这也是一个正常的的请求的话，因此建立了连接，可以想象，这个连接不会进行下去，也没有个终结的时候，纯属单相思了。因而两次握手肯定不行。</p>

<p><font size="3" color="red">B</font> 发送的应答可能会发送多次，但是只要一次到达 <font size="3" color="red">A</font>，<font size="3" color="red">A</font> 就认为连接<font size="3" color="red">已经建立</font>了，因为对于 <font size="3" color="red">A</font> 来讲，他的消息有去有回。<font size="3" color="red">A</font> 会给 <font size="3" color="red">B 发送应答之应答</font>，而 <font size="3" color="red">B</font> 也在等这个消息，才能确认连接的建立，只有等到了这个消息，对于 <font size="3" color="red">B</font> 来讲，才算它的消息有去有回。</p>

<p>当然<font size="3" color="red"> A</font> 发给 <font size="3" color="red">B</font> 的<font size="3" color="red">应答之应答</font>也会丢，也会绕路，甚至 <font size="3" color="red">B</font> 挂了。按理来说，还应该有个<font size="3" color="red">应答之应答之应答</font>，这样下去就没底了。所以<font size="3" color="red">四次握手是可以的</font>，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以了。</p>

<p>好在大部分情况下，<font size="3" color="red">A</font> 和 <font size="3" color="red">B</font> 建立了连接之后，<font size="3" color="red">A</font> 会马上发送数据的，一旦 <font size="3" color="red">A</font> 发送数据，则很多问题都得到了解决。例如 <font size="3" color="red">A</font> 发给 <font size="3" color="red">B</font> 的应答丢了，当 <font size="3" color="red">A</font> 后续发送的数据到达的时候，<font size="3" color="red">B</font> 可以认为这个连接已经建立，或者 <font size="3" color="red">B</font> 压根就挂了，<font size="3" color="red">A </font>发送的数据，会报错，说 <font size="3" color="red">B</font> 不可达，<font size="3" color="red">A</font> 就知道 <font size="3" color="red">B</font> 出事情了。</p>

<p>当然你可以说 A 比较坏，就是不发数据，建立连接后空着。我们在程序设计的时候，可以要求开启 keepalive 机制，即使没有真实的数据包，也有探活包。</p><br><p>另外，你作为服务端 B 的程序设计者，对于 A 这种长时间不发包的客户端，可以主动关闭，从而空出资源来给其他客户端使用。</p><br><p>三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是<strong><font size="3" color="red">TCP 包的序号的问题</font></strong>。</p>

<p>发起的包的序号起始是从哪个号开始的。<font size="3" color="red">为什么序号不能都从 1 开始呢？</font>因为这样往往会出现冲突。</p><p></p>
<p>例如，<font size="3" color="red">A</font> 连上 <font size="3" color="red">B</font> 之后，发送了 <font size="3" color="red">1、2、3 </font>三个包，但是发送 <font size="3" color="red">3</font> 的时候，中间丢了，或者绕路了，于是重新发送，后来 <font size="3" color="red">A</font> 掉线了，重新连上 <font size="3" color="red">B</font> 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 <font size="3" color="red">B</font>，<font size="3" color="red">B</font> 自然认为，这就是下一个包，于是发生了错误。</p><br><p>因而，<font size="3" color="red">每个连接都要有不同的序号</font>。这个<font size="3" color="red">序号</font>的<font size="3" color="red">起始序号</font>是<font size="3" color="red">随着时间变化的</font>，可以看成一个 32 位的计数器，每 4ms 加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我们都知道 IP 包头里面有个 TTL，也即生存时间。</p>

<p><font size="3" color="red">A</font> 要告诉<font size="3" color="red"> B</font>，我这面发起的包的序号起始是从哪个号开始的，<font size="3" color="red">B</font> 同样也要告诉 <font size="3" color="red">A</font>，<font size="3" color="red">B</font><br></p><p>好了，双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p>

<p><img src="https://static001.geekbang.org/resource/image/66/a2/666d7d20aa907d8317af3770411f5aa2.jpg" alt="image"></p>
<p>一开始，客户端和服务端都处于 <font size="3" color="red">CLOSED</font> 状态。先是服务端主动监听某个端口，处于 <font size="3" color="red">LISTEN</font> 状态。然后<font size="3" color="red">客户端</font>主动发起连接 <font size="3" color="red">SYN</font>，之后处于 <font size="3" color="red">SYN-SENT</font> 状态。服务端收到发起的连接，返回 <font size="3" color="red">SYN</font>，并且 <font size="3" color="red">ACK</font> 客户端的 <font size="3" color="red">SYN</font>，之后处于 <font size="3" color="red">SYN-RCVD</font> 状态。客户端收到服务端发送的 <font size="3" color="red">SYN</font> 和 <font size="3" color="red">ACK</font> 之后，发送 <font size="3" color="red">ACK</font> 的 <font size="3" color="red">ACK</font>，之后处于 <font size="3" color="red">ESTABLISHED</font> 状态，因为它一发一收成功了。服务端收到 <font size="3" color="red">ACK 的 ACK</font> 之后，处于 <font size="3" color="red">ESTABLISHED</font> 状态，因为它也一发一收了。</p>

<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>好了，说完了连接，接下来说一说“拜拜”，好说好散。这常被称为四次挥手。</p><br><p>A：B 啊，我不想玩了。</p><br><p>B：哦，你不想玩了啊，我知道了。</p><br><p>这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢？当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为半关闭的状态。</p><br><p>这个时候 A 可以选择不再接收数据了，也可以选择最后再接收一段数据，等待 B 也主动关闭。</p><br><p>B：A 啊，好吧，我也不玩了，拜拜。</p><br><p>A：好的，拜拜。</p><br><p>这样整个连接就关闭了。但是这个过程有没有异常情况呢？当然有，上面是和平分手的场面。</p>

<p><font size="3" color="red">A</font> 开始说“不玩了”，<font size="3" color="red">B</font> 说“知道了”，这个回合，是没什么问题的，因为在此之前，双方还处于合作的状态，如果 <font size="3" color="red">A</font> 说“不玩了”，没有收到回复，则<font size="3" color="red"> A</font> 会重新发送“不玩了”。但是这个回合结束之后，就有可能出现异常情况了，因为已经有一方率先撕破脸。</p><br><p>一种情况是，<font size="3" color="red">A</font> 说完“不玩了”之后，直接跑路，是会有问题的，因为 <font size="3" color="red">B</font> 还没有发起结束，而如果 <font size="3" color="red">A</font> 跑路，<font size="3" color="red">B</font> 就算发起结束，也得不到回答，<font size="3" color="red">B</font> 就不知道该怎么办了。另一种情况是，<font size="3" color="red">A</font> 说完“不玩了”，<font size="3" color="red">B</font> 直接跑路，也是有问题的，因为 <font size="3" color="red">A</font> 不知道 <font size="3" color="red">B</font> 是还有事情要处理，还是过一会儿会发送结束。</p>

<p>那怎么解决这些问题呢？<font size="3" color="red">TCP</font> 协议专门设计了几个状态来处理这些问题。我们来看断开连接的时候的<strong>状态时序图</strong>。</p>

<p><img src="https://static001.geekbang.org/resource/image/1f/11/1f6a5e17b34f00d28722428b7b8ccb11.jpg" alt="image"></p>
<p>断开的时候，我们可以看到，当 <font size="3" color="red">A</font> 说“不玩了”，就进入 <font size="3" color="red">FIN_WAIT_1</font> 的状态，<font size="3" color="red">B</font> 收到“A 不玩”的消息后，发送知道了，就进入 <font size="3" color="red">CLOSE_WAIT</font> 的状态。</p><br><p><font size="3" color="red">A</font> 收到“B 说知道了”，就进入 <font size="3" color="red">FIN_WAIT_2</font> 的状态，如果这个时候 <font size="3" color="red">B</font> 直接跑路，则 <font size="3" color="red">A</font> 将永远在这个状态。<font size="3" color="red">TCP</font> 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p><br><p>如果 <font size="3" color="red">B</font> 没有跑路，发送了<font size="3" color="red">“B 也不玩了”</font>的请求到达 <font size="3" color="red">A</font> 时，<font size="3" color="red">A</font> 发送“知道 B 也不玩了”的 <font size="3" color="red">ACK</font> 后，从 <font size="3" color="red">FIN_WAIT_2</font> 状态结束，按说 <font size="3" color="red">A</font> 可以跑路了，但是最后的这个 <font size="3" color="red">ACK</font> 万一 <font size="3" color="red">B</font> 收不到呢？则 <font size="3" color="red">B</font> 会重新发一个“B 不玩了”，这个时候 <font size="3" color="red">A</font> 已经跑路了的话，<font size="3" color="red">B</font> 就再也收不到 <font size="3" color="red">ACK</font> 了，因而 <font size="3" color="red">TCP</font> 协议要求 <font size="3" color="red">A</font> 最后等待一段时间 <font size="3" color="red">TIME_WAIT</font>，这个时间要足够长，长到如果 <font size="3" color="red">B</font> 没收到 <font size="3" color="red">ACK</font> 的话，“B 说不玩了”会重发的，<font size="3" color="red">A</font> 会重新发一个 <font size="3" color="red">ACK</font> 并且足够时间到达 <font size="3" color="red">B</font>。</p><br><p><font size="3" color="red">A</font> 直接跑路还有一个问题是，<font size="3" color="red">A</font> 的端口就直接空出来了，但是 <font size="3" color="red">B</font> 不知道，<font size="3" color="red">B</font> 原来发过的很多包很可能还在路上，如果 <font size="3" color="red">A</font> 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 <font size="3" color="red">B</font> 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 <font size="3" color="red">B</font> 发送的所有的包都死翘翘，再空出端口来。</p>

<p>等待的时间设为 2MSL，<strong>MSL</strong>是<strong>Maximum Segment Lifetime</strong>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。</p><br><p>还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。</p>

<h3 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h3><p>将连接建立和连接断开的两个时序状态图综合起来，就是这个著名的 TCP 的状态机。学习的时候比较建议将这个状态机和时序状态机对照着看，不然容易晕。</p>

<p><img src="https://static001.geekbang.org/resource/image/da/ab/dab9f6ee2908b05ed6f15f3e21be88ab.jpg" alt="image"></p>
<p>在这个图中，加黑加粗的部分，是上面说到的主要流程，其中阿拉伯数字的序号，是连接过程中的顺序，而大写中文数字的序号，是连接断开过程中的顺序。加粗的实线是客户端 A 的状态变迁，加粗的虚线是服务端 B 的状态变迁。</p>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><br><li><p>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；</p><br></li><br><li><p>连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的我画的那个状态图。</p><br></li><br></ul>

<p></p><p>最后，给你留两个思考题。</p><p></p>
<ol><br><li><p>TCP 的连接有这么多的状态，你知道如何在系统中查看某个连接的状态吗？</p><br></li><br><li><p>这一节仅仅讲了连接维护问题，其实为了维护连接的状态，还有其他的数据结构来处理其他的四个问题，那你知道是什么吗？</p><br></li><br></ol>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/十、UDP协议：因性善而简单，难免碰到“城会玩”/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/十、UDP协议：因性善而简单，难免碰到“城会玩”/" class="post-title-link" itemprop="url">十、UDP协议：因性善而简单，难免碰到“城会玩”</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 11:11:57" itemprop="dateCreated datePublished" datetime="2019-03-28T11:11:57+08:00">2019-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>讲完了 IP 层以后，接下来我们开始讲传输层。传输层里比较重要的两个协议，一个是 TCP，一个是 UDP。对于不从事底层开发的人员来讲，或者对于开发应用的人来讲，最常用的就是这两个协议。由于面试的时候，这两个协议经常会被放在一起问，因而我在讲的时候，也会结合着来讲。</p>
<h3 id="TCP-和-UDP-有哪些区别？"><a href="#TCP-和-UDP-有哪些区别？" class="headerlink" title="TCP 和 UDP 有哪些区别？"></a>TCP 和 UDP 有哪些区别？</h3><p>一般面试的时候我问这两个协议的区别，大部分人会回答，<font size="3" color="red">TCP</font> 是面向连接的，<font size="3" color="red">UDP</font> 是面向无连接的。</p><br><p>什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，<font size="3" color="red">TCP 会三次握手</font>，而 <font size="3" color="red">UDP</font> 不会。为什么要建立连接呢？你 <font size="3" color="red">TCP</font> 三次握手，我 <font size="3" color="red">UDP</font> 也可以发三个包玩玩，有什么区别吗？</p>

<p><font size="3" color="red">所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</font></p>

<p>例如，<font size="3" color="red">TCP 提供可靠交付</font>。通过 <font size="3" color="red">TCP</font> 连接传输的数据，无差错、不丢失、不重复、并且按序到达。我们都知道 <font size="3" color="red">IP</font> 包是没有任何可靠性保证的，一旦发出去，就像西天取经，走丢了、被妖怪吃了，都只能随它去。但是 <font size="3" color="red">TCP</font> 号称能做到那个连接维护的程序做的事情，这个下两节我会详细描述。而<font size="3" color="red">UDP继承了 IP包的特性，不保证不丢失，不保证按顺序到达。</font></p>

<p>再如，<font size="3" color="red">TCP 是面向字节流的</font>。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而<font size="3" color="red">UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。</font></p>

<p>还有<font size="3" color="red">TCP 是可以有拥塞控制的</font>。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。<font size="3" color="red">UDP 就不会，应用让我发，我就发，管它洪水滔天。</font></p>

<p>因而<font size="3" color="red">TCP 其实是一个有状态服务</font>，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 <font size="3" color="red">UDP 则是无状态服务。</font> 通俗地说是没脑子的，天真无邪的，发出去就发出去了。</p>

<p>我们可以这样比喻，如果 <font size="3" color="red">MAC</font> 层定义了本地局域网的传输行为，<font size="3" color="red">IP</font> 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：网络传输是以包为单位的，二层叫<font size="3" color="red">帧</font>，网络层叫<font size="3" color="red">包</font>，传输层叫<font size="3" color="red">段</font>。我们<font size="3" color="red">笼统地称为包</font>。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因，生下来的孩子 <font size="3" color="red">UDP</font> 完全继承了这些特性，几乎没有自己的思想。</p>

<h3 id="UDP-包头是什么样的？"><a href="#UDP-包头是什么样的？" class="headerlink" title="UDP 包头是什么样的？"></a>UDP 包头是什么样的？</h3><p>我们来看一下 <font size="3" color="red">UDP</font> 包头。</p>

<p>前面章节我已经讲过包的传输过程，这里不再赘述。当我发送的<font size="3" color="red"> UDP</font> 包到达目标机器后，发现 <font size="3" color="red">MAC</font> 地址匹配，于是就取下来，将剩下的包传给处理 <font size="3" color="red">IP</font> 层的代码。把 <font size="3" color="red">IP</font> 头取下来，发现目标 <font size="3" color="red">IP</font> 匹配，接下来呢？这里面的数据包是给谁呢？</p>

<p>发送的时候，我知道我发的是一个 <font size="3" color="red">UDP</font> 的包，收到的那台机器咋知道的呢？所以在 <font size="3" color="red">IP 头</font>里面有个 <font size="3" color="red">8 位协议</font>，这里会存放，数据里面到底是 <font size="3" color="red">TCP</font> 还是 <font size="3" color="red">UDP</font>，当然这里是<font size="3" color="red"> UDP</font>。于是，如果我们知道 <font size="3" color="red">UDP</font> 头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？</p>

<p>处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？</p>

<p>无论应用程序写的使用 <font size="3" color="red">TCP</font> 传数据，还是<font size="3" color="red"> UDP</font> 传数据，都要监听一个<font size="3" color="red">端口</font>。正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？所以，按理说，无论是 <font size="3" color="red">TCP</font> 还是 <font size="3" color="red">UDP</font> 包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。<br><br><br><img src="https://static001.geekbang.org/resource/image/6d/bf/6d1313f51b9dfd7ab454b2cef1cb37bf.jpg" alt="image"><br><br></p><p>当我们看到 <font size="3" color="red">UDP</font> 包头的时候，发现的确有端口号，有源端口号和目标端口号。因为是两端通信嘛，这很好理解。但是你还会发现，<font size="3" color="red">UDP</font> 除了端口号，再没有其他的了。和下两节要讲的 <font size="3" color="red">TCP</font> 头比起来，这个简直简单得一塌糊涂啊！</p>

<h3 id="UDP-的三大特点"><a href="#UDP-的三大特点" class="headerlink" title="UDP 的三大特点"></a>UDP 的三大特点</h3><p>UDP 就像小孩子一样，有以下这些特点：</p>

<p>第一，<font size="3" color="red">沟通简单</font>，不需要一肚子花花肠子（大量的数据结构、处理逻辑、包头字段）。前提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。</p><br><p>第二，<font size="3" color="red">轻信他人</font>。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。</p><br><p>第三，<font size="3" color="red">愣头青，做事不懂权变</font>。不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</p>

<h3 id="UDP-的三大使用场景"><a href="#UDP-的三大使用场景" class="headerlink" title="UDP 的三大使用场景"></a>UDP 的三大使用场景</h3><p>基于 UDP 这种“小孩子”的特点，我们可以考虑在以下的场景中使用。</p><br><p>第一，<font size="3" color="red">需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</font>。这很好理解，就像如果你是领导，你会让你们组刚毕业的小朋友去做一些没有那么难的项目，打一些没有那么难的客户，或者做一些失败了也能忍受的实验性项目。</p><br><p>我们在第四节讲的 <font size="3" color="red">DHCP</font> 就是基于 <font size="3" color="red">UDP</font> 协议的。一般的获取 <font size="3" color="red">IP</font> 地址都是内网请求，而且一次获取不到 <font size="3" color="red">IP</font> 又没事，过一会儿还有机会。我们讲过 <font size="3" color="red">PXE</font> 可以在启动的时候自动安装操作系统，操作系统镜像的下载使用的 <font size="3" color="red">TFTP</font>，这个也是基于 <font size="3" color="red">UDP</font> 协议的。在还没有操作系统的时候，客户端拥有的资源很少，不适合维护一个复杂的状态机，而是因为是内网，一般也没啥问题。</p>

<p>第二，<font size="3" color="red">不需要一对一沟通，建立连接，而是可以广播的应用</font>。咱们小时候人都很简单，大家在班级里面，谁成绩好，谁写作好，应该表扬谁惩罚谁，谁得几个小红花都是当着全班的面讲的，公平公正公开。长大了人心复杂了，薪水、奖金要背靠背，和员工一对一沟通。</p><br><p><font size="3" color="red">UDP</font> 的不面向连接的功能，可以使得可以承载广播或者多播的协议。<font size="3" color="red">DHCP</font> 就是一种广播的形式，就是基于 <font size="3" color="red">UDP</font> 协议的，而广播包的格式前面说过了。</p><br><p>对于多播，我们在讲 <font size="3" color="red">IP</font> 地址的时候，讲过一个 <font size="3" color="red">D</font> 类地址，也即组播地址，使用这个地址，可以将包组播给一批机器。当一台机器上的某个进程想监听某个组播地址的时候，需要发送 <font size="3" color="red">IGMP</font> 包，所在网络的路由器就能收到这个包，知道有个机器上有个进程在监听这个组播地址。当路由器收到这个组播地址的时候，会将包转发给这台机器，这样就实现了跨路由器的组播。</p><br><p>在后面云中网络部分，有一个协议 VXLAN，也是需要用到组播，也是基于 UDP 协议的。</p>

<p>第三，<font size="3" color="red">需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</font>。记得曾国藩建立湘军的时候，专门招出生牛犊不怕虎的新兵，而不用那些“老油条”的八旗兵，就是因为八旗兵经历的事情多，遇到敌军不敢舍死忘生。</p><br><p>同理，<font size="3" color="red">UDP</font> 简单、处理速度快，不像 <font size="3" color="red">TCP</font> 那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而 <font size="3" color="red">TCP</font> 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。</p><br><p>当前很多应用都是要求低时延的，它们可不想用 <font size="3" color="red">TCP</font> 如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于<font size="3" color="red"> TCP</font>。有的前面的包没到，后面的包到了，那就先给客户展示后面的嘛，干嘛非得等到齐了呢？如果网络不好，丢了包，那不能退缩啊，要尽快传啊，速度不能降下来啊，要挤占带宽，抢在客户失去耐心之前到达。</p><br><p>由于 <font size="3" color="red">UDP</font> 十分简单，基本啥都没做，也就给了应用“城会玩”的机会。就像在和平年代，每个人应该有独立的思考和行为，应该可靠并且礼让；但是如果在战争年代，往往不太需要过于独立的思考，而需要士兵简单服从命令就可以了。</p><br><p>曾国藩说哪支部队需要诱敌牺牲，也就牺牲了，相当于包丢了就丢了。两军狭路相逢的时候，曾国藩说上，没有带宽也要上，这才给了曾国藩运筹帷幄，城会玩的机会。同理如果你实现的应用需要有自己的连接策略，可靠保证，时延要求，使用 <font size="3" color="red">UDP</font>，然后再应用层实现这些是再好不过了。</p>

<h3 id="基于-UDP-的“城会玩”的五个例子"><a href="#基于-UDP-的“城会玩”的五个例子" class="headerlink" title="基于 UDP 的“城会玩”的五个例子"></a>基于 UDP 的“城会玩”的五个例子</h3><h4 id="“城会玩”一：网页或者-APP-的访问"><a href="#“城会玩”一：网页或者-APP-的访问" class="headerlink" title="“城会玩”一：网页或者 APP 的访问"></a>“城会玩”一：网页或者 APP 的访问</h4><p>原来访问网页和手机 <font size="3" color="red">APP</font> 都是基于 <font size="3" color="red">HTTP</font> 协议的。<font size="3" color="red">HTTP 协议</font>是<font size="3" color="red">基于 TCP</font> 的，建立连接都需要多次交互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移动中，<font size="3" color="red">TCP</font> 可能还会断了重连，也是很耗时的。而且目前的 <font size="3" color="red">HTTP 协议</font>，往往<font size="3" color="red">采取</font>多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 <font size="3" color="red">TCP</font> 的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。</p><br><p>而<strong>QUIC</strong>（全称<strong>Quick UDP Internet Connections</strong>，<strong>快速 UDP 互联网连接</strong>）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</p><br><p><font size="3" color="red">QUIC</font> 在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制，是应用层“城会玩”的代表。这一节主要是讲 UDP，QUIC 我们放到应用层去讲。</p>

<h4 id="“城会玩”二：流媒体的协议"><a href="#“城会玩”二：流媒体的协议" class="headerlink" title="“城会玩”二：流媒体的协议"></a>“城会玩”二：流媒体的协议</h4><p>现在直播比较火，直播协议多使用 <font size="3" color="red">RTMP</font>，这个协议我们后面的章节也会讲，而这个 <font size="3" color="red">RTMP</font> 协议也是基于 <font size="3" color="red">TCP</font> 的。<font size="3" color="red">TCP</font> 的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着。对于直播来讲，这显然是不合适的，因为老的视频帧丢了其实也就丢了，就算再传过来用户也不在意了，他们要看新的了，如果老是没来就等着，卡顿了，新的也看不了，那就会丢失客户，所以直播，实时性比较比较重要，宁可丢包，也不要卡顿的。</p><br><p>另外，对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧。</p><br><p>还有就是当网络不好的时候，<font size="3" color="red">TCP</font> 协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，<font size="3" color="red">很多直播应用，都基于 UDP 实现了自己的视频传输协议</font>。</p>

<h4 id="“城会玩”三：实时游戏"><a href="#“城会玩”三：实时游戏" class="headerlink" title="“城会玩”三：实时游戏"></a>“城会玩”三：实时游戏</h4><p>游戏有一个特点，就是实时性比较高。快一秒你干掉别人，慢一秒你被别人爆头，所以很多职业玩家会买非常专业的鼠标和键盘，争分夺秒。</p><br><p>因而，实时游戏中客户端和服务端要建立长连接，来保证实时传输。但是游戏玩家很多，服务器却不多。由于维护 TCP 连接需要在内核维护一些数据结构，因而一台机器能够支撑的 TCP 连接数目是有限的，然后 UDP 由于是没有连接的，在异步 IO 机制引入之前，常常是应对海量客户端连接的策略。</p><br><p>另外还是 TCP 的强顺序问题，对战的游戏，对网络的要求很简单，玩家通过客户端发送给服务器鼠标和键盘行走的位置，服务器会处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响应，渲染最新的场景展示给玩家。</p><br><p>如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，然而玩家并不关心过期的数据，激战中卡 1 秒，等能动了都已经死了。</p><br><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p>

<h4 id="“城会玩”四：IoT-物联网"><a href="#“城会玩”四：IoT-物联网" class="headerlink" title="“城会玩”四：IoT 物联网"></a>“城会玩”四：IoT 物联网</h4><p>一方面，物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护 TCP 协议代价太大；另一方面，物联网对实时性要求也很高，而 TCP 还是因为上面的那些原因导致时延大。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的。</p>

<h4 id="“城会玩”五：移动通信领域"><a href="#“城会玩”五：移动通信领域" class="headerlink" title="“城会玩”五：移动通信领域"></a>“城会玩”五：移动通信领域</h4><p>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的。因为移动网络协议比较复杂，而 GTP 协议本身就包含复杂的手机上线下线的通信协议。如果基于 TCP，TCP 的机制就显得非常多余，这部分协议我会在后面的章节单独讲解。</p>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><br><li><br><p>如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前；</p><br></li><br><li><br><p>UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</p><br></li><br></ul>

<p></p><p>最后，给你留两个思考题吧。</p><p></p>
<ol><br><li><br><p>都说 TCP 是面向连接的，在计算机看来，怎么样才算一个连接呢？</p><br></li><br><li><br><p>你知道 TCP 的连接是如何建立，又是如何关闭的吗？</p><br></li><br></ol>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/九、路由协议：西出网关无故人、敢问路在何方/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/九、路由协议：西出网关无故人、敢问路在何方/" class="post-title-link" itemprop="url">九、路由协议：西出网关无故人、敢问路在何方</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 11:11:17" itemprop="dateCreated datePublished" datetime="2019-03-28T11:11:17+08:00">2019-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>俗话说得好，在家千日好，出门一日难。网络包一旦出了网关，就像玄奘西行一样踏上了江湖漂泊的路。</p>
<p>上一节我们描述的是一个相对简单的情形。出了网关之后，只有一条路可以走。但是，网络世界复杂得多，一旦出了网关，会面临着很多路由器，有很多条道路可以选。如何选择一个更快速的道路求取真经呢？这里面还有很多门道可以讲。</p>
<h3 id="如何配置路由？"><a href="#如何配置路由？" class="headerlink" title="如何配置路由？"></a>如何配置路由？</h3><p>通过上一节的内容，你应该已经知道，路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为<strong>路由表</strong>。</p>

<p>一张路由表中会有多条路由规则。每一条规则至少包含这三项信息。</p>

<ul><br><li><p>目的网络：这个包想去哪儿？</p><br></li><br><li><p>出口设备：将包从哪个口扔出去？</p><br></li><br><li><p>下一跳网关：下一个路由器的地址。</p><br></li><br></ul>

<p>通过 <font size="3" color="red">route</font> 命令和 <font size="3" color="red">ip route </font>命令都可以进行查询或者配置。</p><br><p>例如，我们设置 <font size="3" color="red">ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0</font>，就说明要去 <font size="3" color="red">10.176.48.0/20 </font>这个<font size="3" color="red">目标网络</font>，要从 <font size="3" color="red">eth0 端口</font>出去，经过<font size="3" color="red"> 10.173.32.1</font>。</p>

<p>上一节的例子中，网关上的路由策略就是按照这三项配置信息进行配置的。这种配置方式的一个核心思想是：<strong>根据目的 IP 地址来配置路由</strong>。</p>

<h3 id="如何配置策略路由？"><a href="#如何配置策略路由？" class="headerlink" title="如何配置策略路由？"></a>如何配置策略路由？</h3><p>当然，在真实的复杂的网络环境中，除了可以根据目的 ip 地址配置路由外，还可以根据多个参数来配置路由，这就称为<strong>策略路由</strong>。</p>

<p>可以配置多个路由表，可以根据<font size="3" color="red">源 IP 地址</font>、<font size="3" color="red">入口设备</font>、<font size="3" color="red">TOS</font> 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。</p>

<p>例如，我们设置：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip rule add from 192.168.1.0/24 table 10 </span><br><span class="line">ip rule add from 192.168.2.0/24 table 20</span><br></pre></td></tr></table></figure>
<p>表示从 <font size="3" color="red">192.168.1.10/24</font> 这个网段来的，使用 <font size="3" color="red">table 10</font> 中的路由表，而从 <font size="3" color="red">192.168.2.0/24</font> 网段来的，使用 <font size="3" color="red">table20</font> 的路由表。</p>

<p>在一条路由规则中，也可以走多条路径。例如，在下面的路由规则中：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2</span><br></pre></td></tr></table></figure>
<p>下一跳有两个地方，分别是 <font size="3" color="red">100.100.100.1</font> 和 <font size="3" color="red">200.200.200.1</font>，<font size="3" color="red">权重</font>分别为 <font size="3" color="red">1</font> 比<font size="3" color="red"> 2</font>。</p>

<p>在什么情况下会用到如此复杂的配置呢？我来举一个现实中的例子。</p>
<p>我是房东，家里从运营商那儿拉了两根网线。这两根网线分别属于两个运行商。一个带宽大一些，一个带宽小一些。这个时候，我就不能买普通的家用路由器了，得买个高级点的，可以接两个外网的。</p>

<p>家里的网络呢，就是普通的家用网段 <font size="3" color="red">192.168.1.x/24</font>。家里有<font size="3" color="red">两个</font>租户，分别把线连到路由器上。IP 地址为 <font size="3" color="red">192.168.1.101/24</font> 和 <font size="3" color="red">192.168.1.102/24</font>，网关都是<font size="3" color="red"> 192.168.1.1/24</font>，网关在路由器上。</p>

<p>就像上一节说的一样，家里的网段是私有网段，出去的包需要 NAT 成公网的 IP 地址，因而路由器是一个 NAT 路由器。</p><br><p>两个运营商都要为这个网关配置一个公网的 IP 地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。</p>

<p><img src="https://static001.geekbang.org/resource/image/03/69/03df39f76b60ac2c0a61b75a4dc25869.jpg" alt="image"></p>
<p>运行商里面也有一个 <font size="3" color="red">IP</font> 地址，在运营商网络里面的网关。不同的运营商方法不一样，有的是 <font size="3" color="red">/32 </font>的，也即一个<font size="3" color="red">一对一连接</font>。</p><br><p>例如，运营商 1 给路由器分配的地址是 <font size="3" color="red">183.134.189.34/32</font>，而运营商网络里面的网关是<font size="3" color="red"> 183.134.188.1/32</font>。有的是 <font size="3" color="red">/30</font> 的，也就是分了一个特别小的网段。运营商 2 给路由器分配的地址是 <font size="3" color="red">60.190.27.190/30</font>，运营商网络里面的网关是<font size="3" color="red"> 60.190.27.189/30</font>。</p><br><p>根据这个网络拓扑图，可以将路由配置成这样：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip route list table main </span><br><span class="line">60.190.27.189/30 dev eth3  proto kernel  scope link  src 60.190.27.190</span><br><span class="line">183.134.188.1 dev eth2  proto kernel  scope link  src 183.134.189.34</span><br><span class="line">192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.1</span><br><span class="line">127.0.0.0/8 dev lo  scope link</span><br><span class="line">default via 183.134.188.1 dev eth2</span><br></pre></td></tr></table></figure>
<p>当路由这样配置的时候，就告诉这个路由器如下的规则：</p><br><ul><br><li><p>如果去运营商二，就走 eth3；</p><br></li><br><li><p>如果去运营商一呢，就走 eth2；</p><br></li><br><li><p>如果访问内网，就走 eth1；</p><br></li><br><li><p>如果所有的规则都匹配不上，默认走运营商一，也即走快的网络。</p><br></li><br></ul><br><br><p>但是问题来了，租户 A 不想多付钱，他说我就上上网页，从不看电影，凭什么收我同样贵的网费啊？没关系，咱有技术可以解决。</p>

<p>下面我添加一个 Table，名字叫<strong>chao</strong>。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo 200 chao &gt;&gt; /etc/iproute2/rt_tables</span><br></pre></td></tr></table></figure>
<p>添加一条规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ip rule add from 192.168.1.101 table chao</span><br><span class="line"># ip rule ls</span><br><span class="line">0:    from all lookup local </span><br><span class="line">32765:    from 10.0.0.10 lookup chao</span><br><span class="line">32766:    from all lookup main </span><br><span class="line">32767:    from all lookup default</span><br></pre></td></tr></table></figure>
<p>设定规则为：从 192.168.1.101 来的包都查看个 chao 这个新的路由表。</p>
<p>在 chao 路由表中添加规则：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ip route add default via 60.190.27.189 dev eth3 table chao</span><br><span class="line"># ip route flush cache</span><br></pre></td></tr></table></figure>
<p>默认的路由走慢的，谁让你不付钱。</p><br><p>上面说的都是静态的路由，一般来说网络环境简单的时候，在自己的可控范围之内，自己捣鼓还是可以的。但是有时候网络环境复杂并且多变，如果总是用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。</p>

<h3 id="动态路由算法"><a href="#动态路由算法" class="headerlink" title="动态路由算法"></a>动态路由算法</h3><p>使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。那路由算法是什么样的呢？</p>

<p>我们可以想象唐僧西天取经，需要解决两大问题，一个是在每个国家如何找到正确的路，去换通关文牒、吃饭、休息；一个是在国家之间，野外行走的时候，如何找到正确的路、水源的问题。</p>

<p><img src="https://static001.geekbang.org/resource/image/6d/bb/6d1f0be048a04a08a40b16010f1180bb.jpg" alt="image"></p>
<p>无论是一个国家内部，还是国家之间，我们都可以将复杂的路径，抽象为一种叫作图的数据结构。至于唐僧西行取经，肯定想走得路越少越好，道路越短越好，因而这就转化成为<strong>如何在途中找到最短路径</strong>的问题。</p>

<p>咱们在大学里面学习计算机网络与数据结构的时候，知道求最短路径常用的有两种方法，一种是 <font size="3" color="red">Bellman-Ford</font> 算法，一种是 <font size="3" color="red">Dijkstra</font> 算法。在计算机网络中基本也是用这两种方法计算的。</p>

<h4 id="1、距离矢量路由算法"><a href="#1、距离矢量路由算法" class="headerlink" title="1、距离矢量路由算法"></a>1、距离矢量路由算法</h4><p>第一大类的算法称为<strong>距离矢量路由</strong>（<strong>distance vector routing</strong>）。它是基于 Bellman-Ford 算法的。</p>

<p>这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。</p>

<p>由此可以看出，每个路由器都是知道全局信息的。那这个信息如何更新呢？每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。</p>

<p>每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 <font size="3" color="red">M</font>，而自己距离邻居是 <font size="3" color="red">x</font>，则自己距离目标路由器是 <font size="3" color="red">x+M</font>。</p>

<p>这个算法比较简单，但是还是有问题。</p>
<p><font size="3" color="red">第一个问题就是好消息传得快，坏消息传得慢。</font>如果有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去。要不了多久，整个网络就都知道了。但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。</p>

<p>我再举个例子。</p>

<p><img src="https://static001.geekbang.org/resource/image/64/3f/641b14ede460105d15e23b077532013f.jpg" alt="image"></p>
<p>原来的网络包括两个节点，B 和 C。A 加入了网络，它的邻居 B 很快就发现 A 启动起来了。于是它将自己和 A 的距离设为 1，同样 C 也发现 A 起来了，将自己和 A 的距离设置为 2。但是如果 A 挂掉，情况就不妙了。B 本来和 A 是邻居，发现连不上 A 了，但是 C 还是能够连上，只不过距离远了点，是 2，于是将自己的距离设置为 3。殊不知 C 的距离 2 其实是基于原来自己的距离为 1 计算出来的。C 发现自己也连不上 A，并且发现 B 设置为 3，于是自己改成距离 4。依次类推，数越来越大，直到超过一个阈值，我们才能判定 A 真的挂了。</p>

<p>这个道理有点像有人走丢了。当你突然发现找不到这个人了。于是你去学校问，是不是在他姨家呀？找到他姨家，他姨说，是不是在他舅舅家呀？他舅舅说，是不是在他姥姥家呀？他姥姥说，是不是在学校呀？总归要问一圈，或者是超过一定的时间，大家才会认为这个人的确走丢了。如果这个人其实只是去见了一个谁都不认识的网友去了，当这个人回来的时候，只要他随便见到其中的一个亲戚，这个亲戚就会拉着他到他的家长那里，说你赶紧回家，你妈都找你一天了。</p>

<p><font size="3" color="red">这种算法的第二个问题是，每次发送的时候，要发送整个全局路由表。</font>网络大了，谁也受不了，所以最早的路由协议 RIP 就是这个算法。它适用于小型网络（小于 15 跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了。</p>

<p>所以上面的两个问题，限制了距离矢量路由的网络规模。</p>

<h4 id="2、链路状态路由算法"><a href="#2、链路状态路由算法" class="headerlink" title="2、链路状态路由算法"></a>2、链路状态路由算法</h4><p>第二大类算法是<strong>链路状态路由</strong>（<strong>link state routing</strong>），基于 Dijkstra 算法。</p>

<p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。</p>

<p>不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。</p>

<h3 id="动态路由协议"><a href="#动态路由协议" class="headerlink" title="动态路由协议"></a>动态路由协议</h3><h4 id="1、基于链路状态路由算法的"><a href="#1、基于链路状态路由算法的" class="headerlink" title="1、基于链路状态路由算法的"></a>1、基于链路状态路由算法的</h4><p><strong>OSPF</strong>（<strong>Open Shortest Path First</strong>，<strong>开放式最短路径优先</strong>）就是这样一个基于链路状态路由协议，广泛应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为<strong>内部网关协议</strong>（<strong>Interior Gateway Protocol</strong>，简称<strong>IGP</strong>）。</p>

<p>内部网关协议的重点就是找到最短的路径。在一个组织内部，路径最短往往最优。当然有时候 OSPF 可以发现多个最短的路径，可以在这多个路径中进行负载均衡，这常常被称为<strong>等价路由</strong>。</p>

<p><img src="https://static001.geekbang.org/resource/image/67/9b/6791cdd30119e78fcb3c350223d5049b.jpg" alt="image"></p>
<p>这一点非常重要。有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路。这个在后面我们讲数据中心的网络的时候，一般应用的接入层会有负载均衡 LVS。它可以和 OSPF 一起，实现高吞吐量的接入层设计。</p>

<p>有了内网的路由协议，在一个国家内，唐僧可以想怎么走怎么走了，两条路选一条也行。</p>

<h4 id="2、基于距离矢量路由算法的-BGP"><a href="#2、基于距离矢量路由算法的-BGP" class="headerlink" title="2、基于距离矢量路由算法的 BGP"></a>2、基于距离矢量路由算法的 BGP</h4><p>但是外网的路由协议，也即国家之间的，又有所不同。我们称为<strong>外网路由协议</strong>（<strong>Border Gateway Protocol</strong>，简称<strong>BGP</strong>）。</p>

<p>在一个国家内部，有路当然选近的走。但是国家之间，不光远近的问题，还有政策的问题。例如，唐僧去西天取经，有的路近。但是路过的国家看不惯僧人，见了僧人就抓。例如灭法国，连光头都要抓。这样的情况即便路近，也最好绕远点走。</p>

<p>对于网络包同样，每个数据中心都设置自己的 Policy。例如，哪些外部的 IP 可以让内部知晓，哪些内部的 IP 可以让外部知晓，哪些可以通过，哪些不能通过。这就好比，虽然从我家里到目的地最近，但是不能谁都能从我家走啊！</p>

<p>在网络世界，这一个个国家成为自治系统<strong>AS</strong>（Autonomous System）。自治系统分几种类型。</p>

<ul><br><li><p>Stub AS：对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。</p><br></li><br><li><p>Multihomed AS：可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。</p><br></li><br><li><p>Transit AS：有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。</p><br></li><br></ul>

<p>每个自治系统都有边界路由器，通过它和外面的世界建立联系。</p>

<p><img src="https://static001.geekbang.org/resource/image/c3/43/c3bce0ec298138d8e36e6ebf1375d843.jpg" alt="image"></p>
<p><strong>BGP 又分为两类，eBGP 和 iBGP。</strong>自治系统间，边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。</p>

<p>BGP 协议使用的算法是<strong>路径矢量路由协议</strong>（path-vector protocol）。它是距离矢量路由协议的升级版。</p><br><p>前面说了距离矢量路由协议的缺点。其中一个是收敛慢。在 BGP 里面，除了下一跳 hop 之外，还包括了自治系统 AS 的路径，从而可以避免坏消息传的慢的问题，也即上面所描述的，B 知道 C 原来能够到达 A，是因为通过自己，一旦自己都到达不了 A 了，就不用假设 C 还能到达 A 了。</p><br><p>另外，在路径中将一个自治系统看成一个整体，不区分自治系统内部的路由器，这样自治系统的数目是非常有限的。就像大家都能记住出去玩，从中国出发先到韩国然后到日本，只要不计算细到具体哪一站，就算是发送全局信息，也是没有问题的。</p>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><br><li><p>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</p><br></li><br><li><p>动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。</p><br></li><br></ul>

<p></p><p>最后，再给你留两个思考题：</p><p></p>
<ol><br><li><p>路由协议要在路由器之间交换信息，这些信息的交换还需要走路由吗？不是死锁了吗？</p><br></li><br><li><p>路由器之间信息的交换使用什么协议呢？报文格式是什么样呢？</p><br></li><br></ol>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://pic.superbed.cn/item/5c94a8cf3a213b0417e266a8" alt="Siir">
            
              <p class="site-author-name" itemprop="name">Siir</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">51</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">Kategorien</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">schlagwörter</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/burning-shadow" title="GitHub &rarr; https://github.com/burning-shadow" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/6975656937" title="Weibo &rarr; https://weibo.com/6975656937" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Siir</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  

  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
